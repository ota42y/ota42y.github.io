<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mongodb on おおたの物置</title>
    <link>http://ota42y.com/tags/mongodb/</link>
    <description>Recent content in Mongodb on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 02 Dec 2015 07:25:25 +0900</lastBuildDate>
    
	<atom:link href="http://ota42y.com/tags/mongodb/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MongoDB の update は部分 update ではない</title>
      <link>http://ota42y.com/blog/2015/12/02/mongodb_update/</link>
      <pubDate>Wed, 02 Dec 2015 07:25:25 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/12/02/mongodb_update/</guid>
      <description>まとめ  MongoDB の update はレコードのID以外の要素を全て置き換える 指定したカラムだけ置き換えてはくれない 部分 update したい場合は専用の方法でクエリを作る  MongoDB の update はレコードをほぼ全て置き換える 以下のように insert して update を実行します
db.test.insert({a: 1}) db.test.update({a:1}, {b: 1})  # ruby版 mongo = Mongo::Client.new(&amp;quot;mongodb://localhost&amp;quot;) col = mongo[:test] col.insert_one({ a: 1 }) col.find(a: 1).replace_one({b:1})  insert と update とでキーが違うため、指定した部分だけが書き換わり
{a:1, b:1}
となりそうですが、実際は
{b:1}
と、後のデータで完全上書きされてしまいます。
このように、MongoDB の update はデータの全置き換えを実行します。
なお、ObjectId は変わらないため、消して再度 insert しているのではなく、ObjectId 以外のデータを全て変更しています。
回避方法 もちろん毎度上書きだととても不便なため、回避方法が存在します。
以下のように、update する際に $set のキーとして変更するデータのみを渡します。
これにより、指定したものだけ書き換えられるようになります。
db.test.update({a:1}, {$set:{b: 1}})  # ruby版 col.</description>
    </item>
    
    <item>
      <title>Debian7にapt-getでmongodb3.0が入れられない</title>
      <link>http://ota42y.com/blog/2015/10/14/mongodb3-debian7-32bit/</link>
      <pubDate>Wed, 14 Oct 2015 23:24:16 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/10/14/mongodb3-debian7-32bit/</guid>
      <description>まとめ  Debian 7 32bitではmongodb3.0はapt-getで入れられない tarballで入れられるが、前のmongodbとファイル位置が違うので注意 面倒ならdbファイルを/data/dbに移動してしまうのが楽そう  Debian 7 32bitのmongodb Debian 7 のmongodbを以下の公式サイトの手順で入れようとしても、
3.0が見つからず最高でも2.6までしか入れる事ができません(2015/10/12現在)
Install MongoDB on Debian
mongodbのaptのリポジトリを見ると、amd64版にはたくさんありますが、
i386版のリポジトリは空です。
このため、apt-getでmongodb3.0系を入れるのはできないらしく、
tarballからインストールする必要があります。
ただし、aptで入れた2.6からアップデートし、既存のDBファイルを使う場合は若干面倒になります。
aptからのアップグレード時の注意点 新規に入れる場合は公式サイトの手順通りですが、aptからのアップグレードの場合は問題が起きます。
公式サイトの手順では、ログインユーザで/data/dbをDB書き込み先として使いますが、
aptで入れた2.6系統は特に設定しない場合、mongodbユーザで/var/lib/mongodbにdbファイルを書き込んでいるため、
そのままですと前のDBが読み込めません。
そのため、/usr/bin以下にmongodbを展開し、mongodbユーザで実行可能にするか、
mongodbユーザがtarballの解凍と実行をする必要があります。
今回は後者の方式をとります。
インストール手順 公式サイトの手順からインストール先を変え、実行時にオプションを指定しているだけです。
Install MongoDB From Tarbal
wget http://downloads.mongodb.org/linux/mongodb-linux-i686-3.0.6.tgz tar zxvf mongodb-linux-i686-3.0.6.tgz sudo cp mongodb-linux-i686-3.0.6/bin/* /usr/bin  起動は以下のようにユーザとdb位置を指定します
sudo -u mongodb mongod --dbpath /var/lib/mongodb  まとめ 起動が面倒なら、/var/lib/mongodbを/data/dbに移動して所有権を書き換えるのもいいと思います。</description>
    </item>
    
    <item>
      <title>mgoのConsistencyについて</title>
      <link>http://ota42y.com/blog/2014/09/03/mgo-consistency/</link>
      <pubDate>Wed, 03 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/03/mgo-consistency/</guid>
      <description>mgoのサンプルにあった
session.SetMode(mgo.Monotonic, true)
の意味がよくわからないので調べてみました。
結論から書きますと、これは複数DBを利用した際の、
データの一貫性をどの程度保証するかの設定です。
一貫性制御 mgoには複数のDB間での一貫性を制御する３種類のモードがあります。
const ( Eventual mode = 0 Monotonic mode = 1 Strong mode = 2 )  SetModeにこれを渡すことで、モードを切り替えられます。
それぞれの内容は以下の通りです。
おそらく一貫性がちゃんとしていくに従って、複雑化&amp;amp;遅くなっていきます。
Eventual Consistency 最終的に辻褄が合えばいいよね設定です。
データに変更が無く十分な時間が過ぎると、最終的に全ての更新が反映されます。
更新済みのノードと、そうでないノードが混在する可能性があるため、
どのノードから読み込むのかが固定されない場合、
新しい値を読み込んだ後に、別のノードから古い値を読み込んでしまう…
といったことが起きる可能性があるはずです。
同じノードから読み取る場合は、後述するMonotonic Consistencyと同じになると思います。
Monotonic Consistency あるプロセスが値を参照したら、以降はその値かそれより新しい値が読み込まれるという設定です。
おそらく、値を参照したタイミングで最新かどうかは保証されないが、
少なくとも古い値が読み込まれることはない、という状態だと思われます。
Strong Consistency 常に必ず最新の値が読み込めるという状態です。
一見すると良さそうですが、最新の値が読めるようになるまで読み込めないため、
注意が必要です。</description>
    </item>
    
    <item>
      <title>golangでmongodbを使う</title>
      <link>http://ota42y.com/blog/2014/09/02/go-mongodb/</link>
      <pubDate>Tue, 02 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/02/go-mongodb/</guid>
      <description>mgoというライブラリが便利そうです。
http://labix.org/mgo
以下はtwitterからツイートを取ってきて、
未登録のツイートをmongodbに保存するスクリプトです。
今のところ、検索結果が存在するかどうかを調べる方法が解らなかったので、
件数を数えてその結果をチェックしています。
 </description>
    </item>
    
    <item>
      <title>MongoDBでインデックスとexplainを使う</title>
      <link>http://ota42y.com/blog/2014/09/01/mongodb-explain/</link>
      <pubDate>Mon, 01 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/01/mongodb-explain/</guid>
      <description>事前データ準備  for (var i=0; i&amp;lt;100; i++) { db.test_object.save({name: &amp;quot;test1&amp;quot;, num: i}) } for (var i=0; i&amp;lt;100; i++) { db.test_object.save({name: &amp;quot;test2&amp;quot;, num: i*1000}) } for (var i=0; i&amp;lt;100; i++) { db.test_object.save({name: &amp;quot;test3&amp;quot;, num: i*10000}) }  stringは3種類100個ずつ、numはuniqueなオブジェクトを作成します。
インデックス作成 db.test_object.ensureIndex({&amp;quot;name&amp;quot;: 1})  で、test_objectコレクションのnameに対してインデックスを作成できます。
また、
db.test_object.getIndexes()  でインデックスを確認出来ます。
なお、MongoDBのばあい、インデックスに使用したキーが存在しない場合もあります。 そのような場合は、キーを持っていないものはNULLとして扱われます。
explain 検索したときにindexが使われているかはexplainで確認出来ます。
db.test_object.find({&amp;quot;name&amp;quot;: &amp;quot;test1&amp;quot;, &amp;quot;num&amp;quot;: 10}).explain() { &amp;quot;cursor&amp;quot; : &amp;quot;BtreeCursor name_1&amp;quot;, &amp;quot;isMultiKey&amp;quot; : false, &amp;quot;n&amp;quot; : 1, &amp;quot;nscannedObjects&amp;quot; : 100, &amp;quot;nscanned&amp;quot; : 100, &amp;quot;nscannedObjectsAllPlans&amp;quot; : 100, &amp;quot;nscannedAllPlans&amp;quot; : 100, &amp;quot;scanAndOrder&amp;quot; : false, &amp;quot;indexOnly&amp;quot; : false, &amp;quot;nYields&amp;quot; : 0, &amp;quot;nChunkSkips&amp;quot; : 0, &amp;quot;millis&amp;quot; : 0, &amp;quot;indexBounds&amp;quot; : { &amp;quot;string&amp;quot; : [ [ &amp;quot;test1&amp;quot;, &amp;quot;test1&amp;quot; ] ] }, &amp;quot;server&amp;quot; : &amp;quot;ota42y:27017&amp;quot;, &amp;quot;filterSet&amp;quot; : false }  cursorが BasicCursorではなく、</description>
    </item>
    
  </channel>
</rss>