<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mongodb on おおたの物置</title>
    <link>http://ota42y.com/tags/mongodb/</link>
    <description>Recent content in Mongodb on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 02 Dec 2015 07:25:25 +0900</lastBuildDate>
    <atom:link href="http://ota42y.com/tags/mongodb/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>MongoDB の update は部分 update ではない</title>
      <link>http://ota42y.com/blog/2015/12/02/mongodb_update/</link>
      <pubDate>Wed, 02 Dec 2015 07:25:25 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/12/02/mongodb_update/</guid>
      <description>

&lt;h1 id=&#34;まとめ:621f39d31cd5b5462567615247739831&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;MongoDB の update はレコードのID以外の要素を全て置き換える&lt;/li&gt;
&lt;li&gt;指定したカラムだけ置き換えてはくれない&lt;/li&gt;
&lt;li&gt;部分 update したい場合は専用の方法でクエリを作る&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mongodb-の-update-はレコードをほぼ全て置き換える:621f39d31cd5b5462567615247739831&#34;&gt;MongoDB の update はレコードをほぼ全て置き換える&lt;/h1&gt;

&lt;p&gt;以下のように insert して update を実行します&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.test.insert({a: 1})
db.test.update({a:1}, {b: 1})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# ruby版
mongo = Mongo::Client.new(&amp;quot;mongodb://localhost&amp;quot;)
col = mongo[:test]
col.insert_one({ a: 1 })
col.find(a: 1).replace_one({b:1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;insert と update とでキーが違うため、指定した部分だけが書き換わり&lt;br /&gt;
&lt;code&gt;{a:1, b:1}&lt;/code&gt;&lt;br /&gt;
となりそうですが、実際は&lt;br /&gt;
&lt;code&gt;{b:1}&lt;/code&gt;&lt;br /&gt;
と、後のデータで完全上書きされてしまいます。&lt;/p&gt;

&lt;p&gt;このように、MongoDB の update はデータの全置き換えを実行します。&lt;br /&gt;
なお、ObjectId は変わらないため、消して再度 insert しているのではなく、ObjectId 以外のデータを全て変更しています。&lt;/p&gt;

&lt;h1 id=&#34;回避方法:621f39d31cd5b5462567615247739831&#34;&gt;回避方法&lt;/h1&gt;

&lt;p&gt;もちろん毎度上書きだととても不便なため、回避方法が存在します。&lt;/p&gt;

&lt;p&gt;以下のように、update する際に &lt;code&gt;$set&lt;/code&gt; のキーとして変更するデータのみを渡します。&lt;br /&gt;
これにより、指定したものだけ書き換えられるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.test.update({a:1}, {$set:{b: 1}})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# ruby版
col.insert_one({ a: 1 })
col.find(a: 1).replace_one(&#39;$set&#39; =&amp;gt; {b:1})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Debian7にapt-getでmongodb3.0が入れられない</title>
      <link>http://ota42y.com/blog/2015/10/14/mongodb3-debian7-32bit/</link>
      <pubDate>Wed, 14 Oct 2015 23:24:16 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/10/14/mongodb3-debian7-32bit/</guid>
      <description>

&lt;h1 id=&#34;まとめ:6fb0a1a816b71cb934be2e92d07fd3af&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Debian 7 32bitではmongodb3.0はapt-getで入れられない&lt;/li&gt;
&lt;li&gt;tarballで入れられるが、前のmongodbとファイル位置が違うので注意&lt;/li&gt;
&lt;li&gt;面倒ならdbファイルを&lt;code&gt;/data/db&lt;/code&gt;に移動してしまうのが楽そう&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;debian-7-32bitのmongodb:6fb0a1a816b71cb934be2e92d07fd3af&#34;&gt;Debian 7 32bitのmongodb&lt;/h1&gt;

&lt;p&gt;Debian 7 のmongodbを以下の公式サイトの手順で入れようとしても、&lt;br /&gt;
3.0が見つからず最高でも2.6までしか入れる事ができません(2015/10/12現在)&lt;br /&gt;
&lt;a href=&#34;https://docs.mongodb.org/master/tutorial/install-mongodb-on-debian/&#34;&gt;Install MongoDB on Debian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mongodbのaptのリポジトリを見ると、&lt;a href=&#34;http://repo.mongodb.org/apt/debian/dists/wheezy/mongodb-org/3.0/main/binary-amd64/&#34;&gt;amd64版&lt;/a&gt;にはたくさんありますが、&lt;br /&gt;
&lt;a href=&#34;http://repo.mongodb.org/apt/debian/dists/wheezy/mongodb-org/3.0/main/binary-i386/&#34;&gt;i386版&lt;/a&gt;のリポジトリは空です。&lt;/p&gt;

&lt;p&gt;このため、apt-getでmongodb3.0系を入れるのはできないらしく、&lt;br /&gt;
tarballからインストールする必要があります。&lt;/p&gt;

&lt;p&gt;ただし、aptで入れた2.6からアップデートし、既存のDBファイルを使う場合は若干面倒になります。&lt;/p&gt;

&lt;h1 id=&#34;aptからのアップグレード時の注意点:6fb0a1a816b71cb934be2e92d07fd3af&#34;&gt;aptからのアップグレード時の注意点&lt;/h1&gt;

&lt;p&gt;新規に入れる場合は公式サイトの手順通りですが、aptからのアップグレードの場合は問題が起きます。&lt;br /&gt;
公式サイトの手順では、ログインユーザで&lt;code&gt;/data/db&lt;/code&gt;をDB書き込み先として使いますが、&lt;br /&gt;
aptで入れた2.6系統は特に設定しない場合、mongodbユーザで&lt;code&gt;/var/lib/mongodb&lt;/code&gt;にdbファイルを書き込んでいるため、&lt;br /&gt;
そのままですと前のDBが読み込めません。&lt;/p&gt;

&lt;p&gt;そのため、&lt;code&gt;/usr/bin&lt;/code&gt;以下にmongodbを展開し、mongodbユーザで実行可能にするか、&lt;br /&gt;
mongodbユーザがtarballの解凍と実行をする必要があります。&lt;br /&gt;
今回は後者の方式をとります。&lt;/p&gt;

&lt;h1 id=&#34;インストール手順:6fb0a1a816b71cb934be2e92d07fd3af&#34;&gt;インストール手順&lt;/h1&gt;

&lt;p&gt;公式サイトの手順からインストール先を変え、実行時にオプションを指定しているだけです。&lt;br /&gt;
&lt;a href=&#34;https://docs.mongodb.org/master/tutorial/install-mongodb-on-linux/&#34;&gt;Install MongoDB From Tarbal&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget http://downloads.mongodb.org/linux/mongodb-linux-i686-3.0.6.tgz
tar zxvf mongodb-linux-i686-3.0.6.tgz
sudo cp mongodb-linux-i686-3.0.6/bin/* /usr/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動は以下のようにユーザとdb位置を指定します&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo -u mongodb mongod --dbpath /var/lib/mongodb
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ-1:6fb0a1a816b71cb934be2e92d07fd3af&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;起動が面倒なら、&lt;code&gt;/var/lib/mongodb&lt;/code&gt;を&lt;code&gt;/data/db&lt;/code&gt;に移動して所有権を書き換えるのもいいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mgoのConsistencyについて</title>
      <link>http://ota42y.com/blog/2014/09/03/mgo-consistency/</link>
      <pubDate>Wed, 03 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/03/mgo-consistency/</guid>
      <description>

&lt;p&gt;mgoのサンプルにあった&lt;br /&gt;
&lt;code&gt;session.SetMode(mgo.Monotonic, true)&lt;/code&gt;&lt;br /&gt;
の意味がよくわからないので調べてみました。&lt;/p&gt;

&lt;p&gt;結論から書きますと、これは複数DBを利用した際の、&lt;br /&gt;
データの一貫性をどの程度保証するかの設定です。&lt;/p&gt;

&lt;h1 id=&#34;一貫性制御:a3afd0be767c5d82506ee68c700d83ee&#34;&gt;一貫性制御&lt;/h1&gt;

&lt;p&gt;mgoには複数のDB間での一貫性を制御する３種類のモードがあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
  Eventual  mode = 0
  Monotonic mode = 1
  Strong    mode = 2
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SetModeにこれを渡すことで、モードを切り替えられます。&lt;/p&gt;

&lt;p&gt;それぞれの内容は以下の通りです。&lt;br /&gt;
おそらく一貫性がちゃんとしていくに従って、複雑化&amp;amp;遅くなっていきます。&lt;/p&gt;

&lt;h2 id=&#34;eventual-consistency:a3afd0be767c5d82506ee68c700d83ee&#34;&gt;Eventual Consistency&lt;/h2&gt;

&lt;p&gt;最終的に辻褄が合えばいいよね設定です。&lt;br /&gt;
データに変更が無く十分な時間が過ぎると、最終的に全ての更新が反映されます。&lt;/p&gt;

&lt;p&gt;更新済みのノードと、そうでないノードが混在する可能性があるため、&lt;br /&gt;
どのノードから読み込むのかが固定されない場合、&lt;br /&gt;
新しい値を読み込んだ後に、別のノードから古い値を読み込んでしまう…&lt;br /&gt;
といったことが起きる可能性があるはずです。&lt;/p&gt;

&lt;p&gt;同じノードから読み取る場合は、後述するMonotonic Consistencyと同じになると思います。&lt;/p&gt;

&lt;h2 id=&#34;monotonic-consistency:a3afd0be767c5d82506ee68c700d83ee&#34;&gt;Monotonic Consistency&lt;/h2&gt;

&lt;p&gt;あるプロセスが値を参照したら、以降はその値かそれより新しい値が読み込まれるという設定です。&lt;br /&gt;
おそらく、値を参照したタイミングで最新かどうかは保証されないが、&lt;br /&gt;
少なくとも古い値が読み込まれることはない、という状態だと思われます。&lt;/p&gt;

&lt;h2 id=&#34;strong-consistency:a3afd0be767c5d82506ee68c700d83ee&#34;&gt;Strong Consistency&lt;/h2&gt;

&lt;p&gt;常に必ず最新の値が読み込めるという状態です。&lt;br /&gt;
一見すると良さそうですが、最新の値が読めるようになるまで読み込めないため、&lt;br /&gt;
注意が必要です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golangでmongodbを使う</title>
      <link>http://ota42y.com/blog/2014/09/02/go-mongodb/</link>
      <pubDate>Tue, 02 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/02/go-mongodb/</guid>
      <description>&lt;p&gt;mgoというライブラリが便利そうです。&lt;br /&gt;
&lt;a href=&#34;http://labix.org/mgo&#34;&gt;http://labix.org/mgo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以下はtwitterからツイートを取ってきて、&lt;br /&gt;
未登録のツイートをmongodbに保存するスクリプトです。&lt;/p&gt;

&lt;p&gt;今のところ、検索結果が存在するかどうかを調べる方法が解らなかったので、&lt;br /&gt;
件数を数えてその結果をチェックしています。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/ota42y/7e493449beec0fe73f62.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>MongoDBでインデックスとexplainを使う</title>
      <link>http://ota42y.com/blog/2014/09/01/mongodb-explain/</link>
      <pubDate>Mon, 01 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/01/mongodb-explain/</guid>
      <description>

&lt;h1 id=&#34;事前データ準備:7c69230a45f10ec129d1ee4fa0ab55a3&#34;&gt;事前データ準備&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt; for (var i=0; i&amp;lt;100; i++) { db.test_object.save({name: &amp;quot;test1&amp;quot;, num: i}) }
 for (var i=0; i&amp;lt;100; i++) { db.test_object.save({name: &amp;quot;test2&amp;quot;, num: i*1000}) }
 for (var i=0; i&amp;lt;100; i++) { db.test_object.save({name: &amp;quot;test3&amp;quot;, num: i*10000}) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stringは3種類100個ずつ、numはuniqueなオブジェクトを作成します。&lt;/p&gt;

&lt;h1 id=&#34;インデックス作成:7c69230a45f10ec129d1ee4fa0ab55a3&#34;&gt;インデックス作成&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;db.test_object.ensureIndex({&amp;quot;name&amp;quot;: 1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、test_objectコレクションのnameに対してインデックスを作成できます。&lt;/p&gt;

&lt;p&gt;また、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.test_object.getIndexes()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でインデックスを確認出来ます。&lt;/p&gt;

&lt;p&gt;なお、MongoDBのばあい、インデックスに使用したキーが存在しない場合もあります。
そのような場合は、キーを持っていないものはNULLとして扱われます。&lt;/p&gt;

&lt;h1 id=&#34;explain:7c69230a45f10ec129d1ee4fa0ab55a3&#34;&gt;explain&lt;/h1&gt;

&lt;p&gt;検索したときにindexが使われているかはexplainで確認出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.test_object.find({&amp;quot;name&amp;quot;: &amp;quot;test1&amp;quot;, &amp;quot;num&amp;quot;: 10}).explain()
{
        &amp;quot;cursor&amp;quot; : &amp;quot;BtreeCursor name_1&amp;quot;,
        &amp;quot;isMultiKey&amp;quot; : false,
        &amp;quot;n&amp;quot; : 1,
        &amp;quot;nscannedObjects&amp;quot; : 100,
        &amp;quot;nscanned&amp;quot; : 100,
        &amp;quot;nscannedObjectsAllPlans&amp;quot; : 100,
        &amp;quot;nscannedAllPlans&amp;quot; : 100,
        &amp;quot;scanAndOrder&amp;quot; : false,
        &amp;quot;indexOnly&amp;quot; : false,
        &amp;quot;nYields&amp;quot; : 0,
        &amp;quot;nChunkSkips&amp;quot; : 0,
        &amp;quot;millis&amp;quot; : 0,
        &amp;quot;indexBounds&amp;quot; : {
                &amp;quot;string&amp;quot; : [
                        [
                                &amp;quot;test1&amp;quot;,
                                &amp;quot;test1&amp;quot;
                        ]
                ]
        },
        &amp;quot;server&amp;quot; : &amp;quot;ota42y:27017&amp;quot;,
        &amp;quot;filterSet&amp;quot; : false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cursorが BasicCursorではなく、&lt;br /&gt;
getIndexesで表示されたインデックス名が表示されていれば大丈夫です。&lt;/p&gt;

&lt;p&gt;nscannedはキーを使って絞り込みをしたオブジェクトの数です。&lt;br /&gt;
この場合は事前の設定通り、100個の&amp;rdquo;test1&amp;rdquo;をキーに持つオブジェクトが引っかかっています。&lt;br /&gt;
その後numキーによって検索が行われ、&lt;br /&gt;
&amp;ldquo;n&amp;rdquo;の個数分(1件)表示されます。&lt;/p&gt;

&lt;p&gt;できる限りn=nscannedに近くなるようにインデックスを貼ったり、&lt;br /&gt;
検索クエリを工夫するといいと思います。&lt;/p&gt;

&lt;p&gt;詳しくはこちら&lt;br /&gt;
&lt;a href=&#34;http://docs.mongodb.org/manual/reference/method/cursor.explain/&#34;&gt;http://docs.mongodb.org/manual/reference/method/cursor.explain/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>