<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chrome on おおたの物置</title>
    <link>http://localhost:1313/tags/chrome/</link>
    <description>Recent content in Chrome on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 31 Jan 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/chrome/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Evernoteのリンクをアプリで開くChrome拡張を更新した</title>
      <link>http://localhost:1313/blog/2015/01/31/evernote-opener-update/</link>
      <pubDate>Sat, 31 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2015/01/31/evernote-opener-update/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/evernote-url-opener/pjkgaadffbojkgoocbobikkklpajjbgo&#34;&gt;evernote url opener&lt;/a&gt;を更新しました。&lt;/p&gt;

&lt;p&gt;使うためには、EvernoteのユーザIDとShardを調べる必要がありますが、&lt;br /&gt;
ちょっと面倒だったので、ユーザが自分のノートリンクをペーストするだけで、設定するように変更しました。&lt;/p&gt;

&lt;p&gt;Evernoteからコピーできる、&lt;br /&gt;
&lt;code&gt;https://www.evernote.com/shard/USER_SHARD//WORD/USER_ID/NODE_ID/&lt;/code&gt;&lt;br /&gt;
といった形式のリンクを張ることで、USER_SHARDとUSER_IDを保存します。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pixivの検索フィルタ作った</title>
      <link>http://localhost:1313/blog/2014/08/20/pixiv-follow-filter/</link>
      <pubDate>Wed, 20 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/20/pixiv-follow-filter/</guid>
      <description>

&lt;p&gt;まとめ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pixivの検索は全ユーザから&lt;/li&gt;
&lt;li&gt;○○が好きな新しいユーザを探したい時に既にフォローしている人はノイズになる&lt;/li&gt;
&lt;li&gt;検索結果からフォローしている人を非表示にする拡張作った&lt;/li&gt;
&lt;li&gt;DLは&lt;a href=&#34;https://chrome.google.com/webstore/detail/pixivfollowerfilter/oopgkhmlkjnooncplailjfanlichdalp?hl=ja&amp;amp;authuser=1&#34;&gt;ここ&lt;/a&gt;から&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;pixivのイラスト検索でフォロワーを除外できない:fb50430d1383f76f5555f2225e4e2273&#34;&gt;Pixivのイラスト検索でフォロワーを除外できない&lt;/h1&gt;

&lt;p&gt;Pixivでイラスト検索をした場合、全ユーザを対象に検索が行われるため、&lt;br /&gt;
検索結果にフォローしてる人とそうでない人が交じります。&lt;/p&gt;

&lt;p&gt;私の場合、&lt;a href=&#34;http://www.pixiv.net/bookmark_new_illust.php&#34;&gt;フォロー新着作品&lt;/a&gt;を全てチェックしているため、&lt;br /&gt;
検索をする場合は、このイラスト書いてる新しい人を見つけたい！といった目的で行うことがほとんどです。&lt;/p&gt;

&lt;p&gt;そのため、フォロワー以外からの検索を行いたいのですが、&lt;br /&gt;
残念ながらPixivにそのような機能はありませんでした。&lt;/p&gt;

&lt;p&gt;というわけで、Chrome拡張で実現しました。&lt;/p&gt;

&lt;h1 id=&#34;フィルタの基本機能:fb50430d1383f76f5555f2225e4e2273&#34;&gt;フィルタの基本機能&lt;/h1&gt;

&lt;p&gt;DLは&lt;a href=&#34;https://chrome.google.com/webstore/detail/pixivfollowerfilter/oopgkhmlkjnooncplailjfanlichdalp?hl=ja&amp;amp;authuser=1&#34;&gt;ここ&lt;/a&gt;から。&lt;/p&gt;

&lt;p&gt;検索結果にはユーザのユニークIDが含まれているため、&lt;br /&gt;
自分のフォローしている人と一致していれば非表示にしています。&lt;/p&gt;

&lt;p&gt;また、毎回通信するのは無駄が多いため、&lt;br /&gt;
事前にフォローしている人のIDをローカルに保存し、そこから読み出しています。&lt;br /&gt;
そのため、ポップアップウィンドウから定期的にデータの更新をする必要があります。&lt;/p&gt;

&lt;h1 id=&#34;ソースコード:fb50430d1383f76f5555f2225e4e2273&#34;&gt;ソースコード&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ota42y/pixiv_follower_filter&#34;&gt;https://github.com/ota42y/pixiv_follower_filter&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>chrome extensionでデータを保存する</title>
      <link>http://localhost:1313/blog/2014/08/17/local-storage/</link>
      <pubDate>Sun, 17 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/17/local-storage/</guid>
      <description>

&lt;p&gt;Chrome拡張でデータを保存しようとした場合に、&lt;br /&gt;
最も簡単に扱えるのが、localStorageです。&lt;/p&gt;

&lt;h1 id=&#34;manifest-jsonの設定:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;manifest.jsonの設定&lt;/h1&gt;

&lt;p&gt;manifest.jsonに以下のパーミッションを追加してください&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;permissions&amp;quot;: [
    &amp;quot;storage&amp;quot;,
    &amp;quot;unlimitedStorage&amp;quot;
  ],

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;使い方:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;使い方&lt;/h1&gt;

&lt;p&gt;localStorageという辞書型の変数が定義されるので、&lt;br /&gt;
それに対して読み書きを行うだけで大丈夫です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;localStorage[‘data’] = ‘aaa&#39;
var data = localStorage[‘data’]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;注意点:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;注意点&lt;/h1&gt;

&lt;h2 id=&#34;保存形式の制約:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;保存形式の制約&lt;/h2&gt;

&lt;p&gt;この方法で保存できるのは文字列だけになります。&lt;br /&gt;
true/falseを保存しても文字列として出てきますし、&lt;br /&gt;
オブジェクトを入れても正しく保存されません。&lt;/p&gt;

&lt;p&gt;このような場合、JSON.stringifyとJSON.parseを使い、&lt;br /&gt;
JSONに変換して保存すると解決します。&lt;/p&gt;

&lt;h2 id=&#34;読み出せる場所の制約:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;読み出せる場所の制約&lt;/h2&gt;

&lt;p&gt;localStorageはページごとに保存するデータがわかれているため、&lt;br /&gt;
読み書きは同じ場所で行う必要があります。&lt;/p&gt;

&lt;p&gt;基本的にはbackgruond.jsで読み書きを行い、&lt;br /&gt;
content_scriptsやpopupからbackground.jsを呼び出すのがいいと思います。&lt;/p&gt;

&lt;p&gt;popupからは以下のように、background.jsの関数を簡単に呼び出すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// background.jsのgetDataを呼び出す
var data = chrome.extension.getBackgroundPage().getData();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;content_scriptsからは直接アクセスできないため、&lt;br /&gt;
メッセージを通して呼び出す必要があり、少々面倒です。&lt;/p&gt;

&lt;p&gt;まず、background側にメッセージ受け取りと、コールバックを定義します。&lt;br /&gt;
content_scriptsからのメッセージ内容がrequestに入っているので、&lt;br /&gt;
それによって処理を分けています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
  if (request.method == &amp;quot;getUser&amp;quot;){
    sendResponse({user_id: localStorage[request.user_id]});
  }else{
    sendResponse({});
  }
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;content_scriptから呼び出す場合は以下のように、&lt;br /&gt;
データとコールバックを渡します。&lt;br /&gt;
受け取り側でsendResponse()を読んだときの引数がresponseに入るので、&lt;br /&gt;
それを利用してデータを取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.runtime.sendMessage({method: &amp;quot;getUser&amp;quot;, user_id: user_id},
 function(response) {
  if(response.user_name){
    console.log(response.user_name);
  }
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>