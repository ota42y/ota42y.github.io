<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on おおたの物置</title>
    <link>http://ota42y.com/tags/linux/index.xml</link>
    <description>Recent content in Linux on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="http://ota42y.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>dump/restoreコマンドでデータのバックアップ・リストアをする</title>
      <link>http://ota42y.com/blog/2016/02/07/dump_restore_command/</link>
      <pubDate>Sun, 07 Feb 2016 12:27:38 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2016/02/07/dump_restore_command/</guid>
      <description>

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;dump/restoreコマンドでパーティションごとバックアップ/リストアができる&lt;/li&gt;
&lt;li&gt;SDカードの中身を移行するのに便利

&lt;ul&gt;
&lt;li&gt;もちろんHDDでもいける&lt;/li&gt;
&lt;li&gt;Windowsは基本的にSDカードの第一パーティションしか認識できない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sdカードのデータ移行がしたい&#34;&gt;SDカードのデータ移行がしたい&lt;/h1&gt;

&lt;p&gt;Androidに使っているMicroSDが速度面で不満が出てきたため、より早い物に入れ替えを行いました。&lt;/p&gt;

&lt;p&gt;ですが、アプリのデータを入れていたりと、通常のMicroSDと使い方がだいぶ違うため、普通にコピペでバックアップ・リストアすると、権限周りやシンボリックリンク周りで問題が起きそうでした。&lt;br /&gt;
&lt;a href=&#34;http://ota42y.com/blog/2014/12/30/link2sd/&#34;&gt;ASUS MeMO Pad 7 ME572CでLink2SDを動かす&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そこで、dump/restoreコマンドを使い、ファイルシステムを丸ごとバックアップ・リストアしました。今回の対象はSDカードですが、対象のデバイスは関係ないため、  HDDを対象としたバックアップも同じ手順で可能です。&lt;/p&gt;

&lt;h1 id=&#34;sdカードの第二パーティションのマウント&#34;&gt;SDカードの第二パーティションのマウント&lt;/h1&gt;

&lt;p&gt;Link2SDを使っているため、SDカードの第二パーティションにバックアップ対象が保存されています。このパーティションをマウントし、dumpコマンドを利用してバックアップを行います。&lt;/p&gt;

&lt;p&gt;なお、Windowsでは基本的にSDカードの第二パーティションはマウントできないため、Linux上で作業を行いました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 接続された位置をfdiskで調べる
sudo fdisk -l

# 以下のようにSDカードのパーティションの位置が表示される
# /dev/sdc1 42 42424242 4242424242 42 HPFS/NTFS/exFAT
# /dev/sdc2 4242 42424242 42424242 42 Linux

# ext3でフォーマットしているのでマウントする
# (どうフォーマットしているかはその人次第です)
sudo mount -t ext3 /dev/sdc2 /mnt/sd
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;dumpコマンドでバックアップ&#34;&gt;dumpコマンドでバックアップ&lt;/h1&gt;

&lt;p&gt;dumpコマンドを使うことで、ファイルシステムがext2,ext3,ext4のものをバックアップできます。
差分バックアップもサポートしていますが、今回はデータ移行が目的なのでフルバックアップを行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# mount先の/mnt/sd以下をバックアップ
sudo dump -0 -f /data/sd.dump /mnt/sd

# -0でダンプレベル0(フルバックアップ)
# -fでバックアップしたデータのファイル名を指定
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;restoreコマンドでリストア&#34;&gt;restoreコマンドでリストア&lt;/h1&gt;

&lt;p&gt;restoreコマンドを使うことで、dumpコマンドでバックアップしたデータをリストアできます。
バックアップが終わった時点でSDカードをフォーマット済みの新しい物に差し替え、
上記の手順で同じ場所にマウントしてあります。&lt;/p&gt;

&lt;p&gt;なお、restoreコマンドはリストア先を指定できそうなオプションが存在します。
ですが何故か上手く動かず、デフォルトの挙動であるカレントディレクトリにリストアされてしまうため、
事前にマウント先に移動しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /mnt/sd
restore -r -f /data/sd.dump
# -rでデータをフルリストア
# -fでバックアップしたファイルを指定
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;時間がかかりますが、以上の手順でデータ移行が完了します。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debian7にapt-getでmongodb3.0が入れられない</title>
      <link>http://ota42y.com/blog/2015/10/14/mongodb3-debian7-32bit/</link>
      <pubDate>Wed, 14 Oct 2015 23:24:16 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/10/14/mongodb3-debian7-32bit/</guid>
      <description>

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Debian 7 32bitではmongodb3.0はapt-getで入れられない&lt;/li&gt;
&lt;li&gt;tarballで入れられるが、前のmongodbとファイル位置が違うので注意&lt;/li&gt;
&lt;li&gt;面倒ならdbファイルを&lt;code&gt;/data/db&lt;/code&gt;に移動してしまうのが楽そう&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;debian-7-32bitのmongodb&#34;&gt;Debian 7 32bitのmongodb&lt;/h1&gt;

&lt;p&gt;Debian 7 のmongodbを以下の公式サイトの手順で入れようとしても、&lt;br /&gt;
3.0が見つからず最高でも2.6までしか入れる事ができません(2015/10/12現在)&lt;br /&gt;
&lt;a href=&#34;https://docs.mongodb.org/master/tutorial/install-mongodb-on-debian/&#34;&gt;Install MongoDB on Debian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mongodbのaptのリポジトリを見ると、&lt;a href=&#34;http://repo.mongodb.org/apt/debian/dists/wheezy/mongodb-org/3.0/main/binary-amd64/&#34;&gt;amd64版&lt;/a&gt;にはたくさんありますが、&lt;br /&gt;
&lt;a href=&#34;http://repo.mongodb.org/apt/debian/dists/wheezy/mongodb-org/3.0/main/binary-i386/&#34;&gt;i386版&lt;/a&gt;のリポジトリは空です。&lt;/p&gt;

&lt;p&gt;このため、apt-getでmongodb3.0系を入れるのはできないらしく、&lt;br /&gt;
tarballからインストールする必要があります。&lt;/p&gt;

&lt;p&gt;ただし、aptで入れた2.6からアップデートし、既存のDBファイルを使う場合は若干面倒になります。&lt;/p&gt;

&lt;h1 id=&#34;aptからのアップグレード時の注意点&#34;&gt;aptからのアップグレード時の注意点&lt;/h1&gt;

&lt;p&gt;新規に入れる場合は公式サイトの手順通りですが、aptからのアップグレードの場合は問題が起きます。&lt;br /&gt;
公式サイトの手順では、ログインユーザで&lt;code&gt;/data/db&lt;/code&gt;をDB書き込み先として使いますが、&lt;br /&gt;
aptで入れた2.6系統は特に設定しない場合、mongodbユーザで&lt;code&gt;/var/lib/mongodb&lt;/code&gt;にdbファイルを書き込んでいるため、&lt;br /&gt;
そのままですと前のDBが読み込めません。&lt;/p&gt;

&lt;p&gt;そのため、&lt;code&gt;/usr/bin&lt;/code&gt;以下にmongodbを展開し、mongodbユーザで実行可能にするか、&lt;br /&gt;
mongodbユーザがtarballの解凍と実行をする必要があります。&lt;br /&gt;
今回は後者の方式をとります。&lt;/p&gt;

&lt;h1 id=&#34;インストール手順&#34;&gt;インストール手順&lt;/h1&gt;

&lt;p&gt;公式サイトの手順からインストール先を変え、実行時にオプションを指定しているだけです。&lt;br /&gt;
&lt;a href=&#34;https://docs.mongodb.org/master/tutorial/install-mongodb-on-linux/&#34;&gt;Install MongoDB From Tarbal&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget http://downloads.mongodb.org/linux/mongodb-linux-i686-3.0.6.tgz
tar zxvf mongodb-linux-i686-3.0.6.tgz
sudo cp mongodb-linux-i686-3.0.6/bin/* /usr/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動は以下のようにユーザとdb位置を指定します&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo -u mongodb mongod --dbpath /var/lib/mongodb
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ-1&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;起動が面倒なら、&lt;code&gt;/var/lib/mongodb&lt;/code&gt;を&lt;code&gt;/data/db&lt;/code&gt;に移動して所有権を書き換えるのもいいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>freeコマンドに新しく追加されたavailableについて</title>
      <link>http://ota42y.com/blog/2015/09/09/free-command/</link>
      <pubDate>Wed, 09 Sep 2015 21:53:07 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/09/09/free-command/</guid>
      <description>

&lt;h1 id=&#34;freeコマンドに追加されたavailable&#34;&gt;freeコマンドに追加されたavailable&lt;/h1&gt;

&lt;p&gt;3.14および2.6.27から、freeコマンドの書式が変わり、&lt;br /&gt;
&lt;code&gt;-/+ buffers/cache&lt;/code&gt;が消えてavailableという項目が増えました。&lt;/p&gt;

&lt;p&gt;availableは&lt;code&gt;/proc/meminfo&lt;/code&gt;の中にあるMemAvailablの値を参照しています。&lt;br /&gt;
この値は、新しいアプリがスワップせずに使える容量はどれくらいか。といった値を示しているようです&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;available
Estimation of how much memory  is  available  for  starting  new
applications,  without swapping. Unlike the data provided by the
cache or free fields, this field takes into account  page  cache
and also that not all reclaimable memory slabs will be reclaimed
due to items being in use (MemAvailable in /proc/meminfo, avail‐
able on kernels 3.14, emulated on kernels 2.6.27+, otherwise the
same as free)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コード&#34;&gt;コード&lt;/h2&gt;

&lt;p&gt;/proc/meminfoは以下のコードによって作成されるようです。&lt;br /&gt;
&lt;a href=&#34;https://github.com/torvalds/linux/blob/master/fs/proc/meminfo.c&#34;&gt;https://github.com/torvalds/linux/blob/master/fs/proc/meminfo.c&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;available = i.freeram - wmark_low;

pagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];
pagecache -= min(pagecache / 2, wmark_low);
available += pagecache;

available += global_page_state(NR_SLAB_RECLAIMABLE) -
			 min(global_page_state(NR_SLAB_RECLAIMABLE) / 2, wmark_low);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コード内容&#34;&gt;コード内容&lt;/h2&gt;

&lt;p&gt;ざっと見たところ、sysinfoのfreeramの値から、ページキャッシュやslabキャッシュの中の再利用可能な分を足した値が、MemAvailableとして計算されるようです。&lt;/p&gt;

&lt;p&gt;実際の空き容量＋直ぐに解放可能な容量＝利用可能なメモリ容量といった感じのようです。&lt;br /&gt;
そのため、ほぼこの値を見てメモリの空き容量を判断してよさそうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linuxのlocaleがおかしくなっていた</title>
      <link>http://ota42y.com/blog/2015/06/03/linux_local/</link>
      <pubDate>Wed, 03 Jun 2015 07:39:36 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/06/03/linux_local/</guid>
      <description>

&lt;p&gt;突然プログラムが起動しなくなったため、&lt;br /&gt;
原因を探ったところ、localesが壊れていました。&lt;br /&gt;
そのため、再インストールすることで直りました。&lt;br /&gt;
言語取得部分は動くけど、おかしい結果を返す壊れ方のため、&lt;br /&gt;
発見にわりと手間取りました。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;プログラム上でlocaleを参照する部分がおかしい結果を返す

&lt;ul&gt;
&lt;li&gt;常にANSI_X3.4-1968&lt;/li&gt;
&lt;li&gt;Debian 7.8&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;dpkg-reconfigure localesが何か壊れているメッセージを出す

&lt;ul&gt;
&lt;li&gt;localeをアップデートすると直る&lt;/li&gt;
&lt;li&gt;apt-get install locales&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;localeの取得がおかしい&#34;&gt;localeの取得がおかしい&lt;/h1&gt;

&lt;p&gt;pythonではgetpreferredencoding()で設定されている言語情報を取ってこれます。
ですが、&lt;br /&gt;
&lt;code&gt;LANG=&#39;ja_JP.UTF-8&#39; echo &#39;import locale; print locale.getpreferredencoding()&#39; | python&lt;/code&gt;&lt;br /&gt;
を実行しても、&lt;code&gt;ANSI_X3.4-1968&lt;/code&gt;が返ってきてしまい、日本語処理の部分でおかしくなっていました。&lt;br /&gt;
(前にそのプログラムは動いていたので、気がついたらおかしくなっていました)&lt;/p&gt;

&lt;p&gt;localeを実行してみたところ、以下のように表示されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;locale -a
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_COLLATE to default locale: No such file or directory
C
C.UTF-8
POSIX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら日本語のlocaleが有効ではないようです。&lt;/p&gt;

&lt;p&gt;ですが、&lt;code&gt;/etc/locale.gen&lt;/code&gt;では、ja_JP.UTF-8がコメントアウトされていて有効になっていました。&lt;/p&gt;

&lt;h1 id=&#34;原因は不明だがとりあえず直る&#34;&gt;原因は不明だがとりあえず直る&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;sudo su
export LC_ALL=C # jaは使えないのでCにする必要がある
export LANG=C # jaは使えないのでCにする必要がある
sudo dpkg-reconfigure locales
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;したら、localesが壊れているというメッセージが出てきました。&lt;/p&gt;

&lt;p&gt;そのため、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install locales
sudo dpkg-reconfigure locales
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、ja_JP.UTF-8を有効にしてリブートしたら上手くいくようになりました。&lt;/p&gt;

&lt;p&gt;おそらくlocales周りがおかしくなっており、新しいlocalesを入れる際にそれが直ったのだと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>fork関数がどうやってプロセスを分割しているか</title>
      <link>http://ota42y.com/blog/2015/01/03/unix-fork/</link>
      <pubDate>Sat, 03 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/03/unix-fork/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%81%AEOS%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AA%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0-~UNIX-V6%E3%81%A7%E5%AD%A6%E3%81%B6%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF-Software-Design/dp/4774154644&#34;&gt;はじめてのOSコードリーディング ~UNIX V6で学ぶカーネルのしくみ&lt;/a&gt;&lt;br /&gt;
という本を読んでいます。&lt;/p&gt;

&lt;p&gt;この中で、fork関数がどうやって子プロセスを作り、&lt;br /&gt;
親子かを識別して別の値を返しているのかが解説されており、&lt;br /&gt;
とても興味深かったです。&lt;/p&gt;

&lt;p&gt;以下にその概要をまとめました。&lt;/p&gt;

&lt;h1 id=&#34;fork関数&#34;&gt;fork関数&lt;/h1&gt;

&lt;p&gt;Cではfork関数を利用することで、子プロセスを作成することが出来ます。&lt;br /&gt;
コードとしてはこんな感じですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

int main() {
  pid_t pid = fork();
  if (pid == 0) {
    sleep(1);
    printf(&amp;quot;child!\n&amp;quot;);
    return 0;
  }

  printf(&amp;quot;parent!\n&amp;quot;);

  int status;
  waitpid(pid, &amp;amp;status, 0);

  printf(&amp;quot;parent end\n&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子プロセスは親プロセスのデータをそのままコピーするため、変数などは全て同じ状態になります。&lt;br /&gt;
ですが、fork関数は親プロセスの場合は子プロセスのIDを、子プロセスでは0を返すため、&lt;br /&gt;
ユーザはfork関数の戻り値を見て、自身が親なのか子なのかを区別できるようになっています。&lt;/p&gt;

&lt;p&gt;では、fork関数の中ではどのようにして、親プロセスか子プロセスかを判断し、&lt;br /&gt;
別の値を返しているのでしょうか。&lt;/p&gt;

&lt;p&gt;これは(UNIX V6では)switch関数の仕様を上手く使った実装により実現されていました。&lt;/p&gt;

&lt;h1 id=&#34;fork関数がプロセスの親子を区別する仕組み&#34;&gt;fork関数がプロセスの親子を区別する仕組み&lt;/h1&gt;

&lt;h2 id=&#34;親による子プロセスの作成&#34;&gt;親による子プロセスの作成&lt;/h2&gt;

&lt;p&gt;ライブラリのfork関数(&lt;a href=&#34;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/source/s4/fork.s&#34;&gt;source/s4/fork.s&lt;/a&gt;)を実行すると、&lt;br /&gt;
システムコールによってカーネルのfork関数(&lt;a href=&#34;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/sys/ken/sys1.c&#34;&gt;sys/ken/sys1.c&lt;/a&gt;)が実行されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;fork()
{
  register struct proc *p1, *p2;

  p1 = u.u_procp;
  for(p2 = &amp;amp;proc[0]; p2 &amp;lt; &amp;amp;proc[NPROC]; p2++)
  if(p2-&amp;gt;p_stat == NULL)
    goto found;
  u.u_error = EAGAIN;
  goto out;

found:
  if(newproc()) {
    u.u_ar0[R0] = p1-&amp;gt;p_pid;
    u.u_cstime[0] = 0;
    u.u_cstime[1] = 0;
    u.u_stime = 0;
    u.u_cutime[0] = 0;
    u.u_cutime[1] = 0;
    u.u_utime = 0;
    return;
  }
  u.u_ar0[R0] = p2-&amp;gt;p_pid;

out:
  u.u_ar0[R7] =+ 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このカーネルのfork関数内でnewproc関数(&lt;a href=&#34;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/sys/ken/slp.c&#34;&gt;sys/ken/slp.c&lt;/a&gt;)を呼び出し、子プロセスを作成しています。&lt;br /&gt;
その後、newproc関数は0を返すため、カーネルのfork関数で0で帰ってきた場合に、&lt;br /&gt;
作成した子プロセスのIDをレジスタに乗せ、ライブラリのfork関数で返すようにしています。&lt;/p&gt;

&lt;h2 id=&#34;作成された子プロセス側の処理&#34;&gt;作成された子プロセス側の処理&lt;/h2&gt;

&lt;p&gt;子プロセスは作成された後、実行順番が回ってきたタイミングでswitch関数(&lt;a href=&#34;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/sys/ken/slp.c&#34;&gt;sys/ken/slp.c&lt;/a&gt;)により再開します。&lt;br /&gt;
この関数内では保存されたデータを復元し、最後にsavu関数を実行した関数の呼び出し元に、return 1で戻ります。&lt;/p&gt;

&lt;p&gt;カーネルのfork関数で呼び出しているnewproc関数(&lt;a href=&#34;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/sys/ken/slp.c&#34;&gt;sys/ken/slp.c&lt;/a&gt;)内では、&lt;br /&gt;
savu関数が実行されてから子プロセスがコピーされるため、&lt;br /&gt;
switch関数はnewprocの呼び出し元であるfork関数に1で戻ります。&lt;/p&gt;

&lt;p&gt;これにより、カーネルのfork関数内で呼び出しているnewproc関数は、&lt;br /&gt;
親プロセスの場合は0が、子プロセスの場合は1が返るようになり、&lt;br /&gt;
その値を見て自身が親なのか子なのかを判断でき、別々の戻り値を返せるようになっています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;親プロセスはforkで子プロセスを作成してそのまま処理を継続&lt;/li&gt;
&lt;li&gt;子プロセスは実行順番が回ってきたタイミングで処理を開始

&lt;ul&gt;
&lt;li&gt;switch関数で復帰した際に、通常とは別の戻り値が返るため親子を区別可能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Debian squeezeでShellShock対策</title>
      <link>http://ota42y.com/blog/2014/09/26/shell-shock/</link>
      <pubDate>Fri, 26 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/26/shell-shock/</guid>
      <description>

&lt;p&gt;Debianは探しても見つからなかったので…(´･_･`)&lt;/p&gt;

&lt;h1 id=&#34;shellshock-cve-2014-6271&#34;&gt;ShellShock(CVE-2014-6271)&lt;/h1&gt;

&lt;p&gt;CVE-2014-6271(とCVE-2014-7169)として、bashに第三者から任意のコードが実行される脆弱性が見つかりました。&lt;br /&gt;
&lt;a href=&#34;https://www.jpcert.or.jp/at/2014/at140037.html&#34;&gt;GNU bash の脆弱性に関する注意喚起&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://d.hatena.ne.jp/Kango/20140925/1411612246&#34;&gt;bashの脆弱性(CVE-2014-6271) #ShellShock の関連リンクをまとめてみた&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://x86-64.jp/blog/CVE-2014-6271&#34;&gt;Blog: bashの脆弱性がヤバすぎる件 – x86-64.jp - くりす研&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;bashで以下のスクリプトを実行し、出力文字列に&lt;code&gt;vulnerable&lt;/code&gt;が出てきたらまずい状態です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;env x=&#39;() { :;}; echo vulnerable&#39; bash -c &#39;echo hello&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;修正パッチ状況&#34;&gt;修正パッチ状況&lt;/h1&gt;

&lt;p&gt;この問題に対しては(まだ不十分ですが)修正パッチが公開されており、また各ディストリビューションでも修正したbashが配布されています。&lt;/p&gt;

&lt;p&gt;Redhad系の対策はこちら&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/richmikan@github/items/5f54114a46e64178133d&#34;&gt;2014/09/24に発表されたBash脆弱性と解決法(RedHat系)&lt;/a&gt;&lt;br /&gt;
Mac OS X系の対策はこちら&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/syui/items/809c1cd8ed57c8cdb055&#34;&gt;CVE-2014-6271のbashの脆弱性に対応する方法&lt;/a&gt;　　&lt;/p&gt;

&lt;p&gt;私の使っているDebian(squeeze)でも、パッチが適応されたbashを配布しています。&lt;br /&gt;
&lt;a href=&#34;https://security-tracker.debian.org/tracker/CVE-2014-6271&#34;&gt;https://security-tracker.debian.org/tracker/CVE-2014-6271&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;修正版へのアップデート&#34;&gt;修正版へのアップデート&lt;/h1&gt;

&lt;p&gt;修正されたbashはsqueezeの通常のリポジトリには修正版は公開されておらず、&lt;br /&gt;
ltsリポジトリを参照する必要があります。(2014/09/26 7:00現在)&lt;br /&gt;
&lt;a href=&#34;https://wiki.debian.org/LTS/Using#Add_squeeze-lts_to_your_sources.list&#34;&gt;LTS/Using - Debian Wiki&lt;/a&gt;にリポジトリが書いてあるので、それをapt-getの参照先に追加します。&lt;/p&gt;

&lt;p&gt;/etc/apt/sources.list.d`に、lts.listを作り、以下のように書き込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://http.debian.net/debian/ squeeze-lts main contrib non-free
deb-src http://http.debian.net/debian/ squeeze-lts main contrib non-free
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(手元に環境がないので確認できませんが、おそらくWheezyでは以下のリポジトリで行けると思います)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://security.debian.org/ wheezy/updates main
deb-src http://security.debian.org/ wheezy/updates main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get update
sudo apt-get install bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をすることで、新しくできます。&lt;/p&gt;

&lt;p&gt;ただし、この修正だけでは不十分という指摘があり、今後さらなる修正パッチが出てくる可能性があります。&lt;br /&gt;
おそらく同じリポジトリに更新が来ると思うので、上記の手順を実行したならば、&lt;br /&gt;
apt-getの&lt;code&gt;update&lt;/code&gt;と&lt;code&gt;install bash&lt;/code&gt;だけですむと思われます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cronやinit.dでsudoを実行するとエラーになって実行できない</title>
      <link>http://ota42y.com/blog/2014/09/13/sudo-error/</link>
      <pubDate>Sat, 13 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/13/sudo-error/</guid>
      <description>&lt;p&gt;cronやinit.d以下に置いたスクリプトで、&lt;br /&gt;
別の以外のユーザで作業しようと思い、sudoを実行したところ、&lt;br /&gt;
以下のようなエラーが出て実行できませんでした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo: sorry, you must have a tty to run sudo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;どうやら、ttyを使わない場合、sudoは権限に関係なく実行できないようです。&lt;/p&gt;

&lt;p&gt;sudoersにある&lt;br /&gt;
&lt;code&gt;Defaults    requiretty&lt;/code&gt;&lt;br /&gt;
をコメントアウトすることで解決しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.idimmu.net/2013/09/27/sudo-sorry-must-tty-run-sudo/&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux起動時に特定のシェルスクリプトを実行する</title>
      <link>http://ota42y.com/blog/2014/09/12/init-d/</link>
      <pubDate>Fri, 12 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/12/init-d/</guid>
      <description>&lt;p&gt;hubotを自動で実行してほしいなーと思ったので、&lt;br /&gt;
OSの起動時にスクリプトを自動実行する方法を調べました。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;/etc/init.d/&lt;/code&gt;
に実行可能なスクリプトを置きます。&lt;/p&gt;

&lt;p&gt;次に、スクリプトの二行目に、起動設定を書きます。&lt;br /&gt;
&lt;code&gt;# chkconfig: 345 99 01&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一つ目がランレベル、二つ目が起動順番、三つ目が終了順番になります。&lt;br /&gt;
起動・終了は小さい数値から行われるため、&lt;br /&gt;
前述の例ですと一番最後に起動し、一番最初に終了します。&lt;/p&gt;

&lt;p&gt;ランレベルについては
&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%83%AC%E3%83%99%E3%83%AB&#34;&gt;Wikipediaの記事&lt;/a&gt;
を参考にしてください&lt;/p&gt;

&lt;p&gt;最後に、&lt;code&gt;chkconfig --add (init.dに置いたスクリプト名)&lt;/code&gt;を実行して登録を行います。&lt;/p&gt;

&lt;p&gt;これで、起動時にスクリプトが実行されます。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>