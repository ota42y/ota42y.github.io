<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Js on おおたの物置</title>
    <link>http://localhost:1313/tags/js/</link>
    <description>Recent content in Js on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 23 Oct 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>javascriptの関数リテラルではインスタンス変数にアクセスできない</title>
      <link>http://localhost:1313/blog/2014/10/23/javascript-callback/</link>
      <pubDate>Thu, 23 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/10/23/javascript-callback/</guid>
      <description>&lt;p&gt;関数リテラルではローカル変数には自由にアクセスできるので、&lt;br /&gt;
ついインスタンスメソッド等にもアクセス出来ると思ってしまいましたが、違うようです。&lt;/p&gt;

&lt;p&gt;以下のように、コールバックとして自分のインスタンスメソッドを呼び出す関数を渡した場合、&lt;br /&gt;
実行時にエラーになります。&lt;br /&gt;
(coffeescriptで書いていますがjavascriptと同じ結果です)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;class Test
  hello: (num) -&amp;gt;
    console.log &amp;quot;hello &amp;quot; + num

  call: (test2) -&amp;gt;
    @hello(1)
    test2.call( -&amp;gt;
      @hello(2)
      )

class Test2
  call: (callback) -&amp;gt;
    callback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数リテラルはそれを作ったオブジェクトとは別のオブジェクトから呼び出されるらしく、&lt;br /&gt;
またその時のthis(coffeescriptなので@hello(2)はthis.hello(2)と等価です)は、&lt;br /&gt;
そのオブジェクトになり、メソッドがないため失敗するようです。&lt;/p&gt;

&lt;p&gt;以下のように、一度thisを待避させることで呼び出すことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;class Test
  hello: (num) -&amp;gt;
    console.log &amp;quot;hello &amp;quot; + num

  call: (test2) -&amp;gt;
    @hello(1)

    self = this
    test2.call( -&amp;gt;
      self.hello(2)
      )

class Test2
  call: (callback) -&amp;gt;
    callback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全なコードはこちら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;class Test
  hello: (num) -&amp;gt;
    console.log &amp;quot;hello &amp;quot; + num

  call: (test2) -&amp;gt;
    @test = &amp;quot;test&amp;quot;
    @hello(1)

    self = this
    test2.call( -&amp;gt;
      # ここで@hello(2) はエラー
      self.hello(2)

      # Test2オブジェクトでもないので、これもエラー
      # @world()
      )

class Test2
  call: (callback) -&amp;gt;
    callback()

  world: -&amp;gt;
    console.log &amp;quot;world&amp;quot;

test = new Test
test2 = new Test2
test.call(test2)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ブラウザからArduinoを制御する</title>
      <link>http://localhost:1313/blog/2014/08/27/arduino-browser/</link>
      <pubDate>Wed, 27 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/27/arduino-browser/</guid>
      <description>

&lt;p&gt;Webブラウザから、接続されているArduinoの値を取りたいのですが、&lt;br /&gt;
当然ながらブラウザ本体やJavascriptにはそんな機能はありません。&lt;/p&gt;

&lt;p&gt;そこで、Arduinoの制御をやるWebサーバをローカルに立てて、&lt;br /&gt;
そこに向けて通信すれば、ブラウザからもArduinoの制御ができるのでは？&lt;br /&gt;
と考えたところ、既にそのようなものがありました。&lt;/p&gt;

&lt;p&gt;試した結果をまとめます。&lt;/p&gt;

&lt;h1 id=&#34;noduino:b54319c1aa56c9cb7b2ee92a8a3c9010&#34;&gt;noduino&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://semu.github.io/noduino/&#34;&gt;http://semu.github.io/noduino/&lt;/a&gt;&lt;br /&gt;
Node.jsでArduinoを制御できます。
&lt;a href=&#34;https://github.com/ecto/duino&#34;&gt;duino&lt;/a&gt;というNode.jsからArduinoに接続するライブラリを利用し、&lt;br /&gt;
Webサーバとして扱えるようにしているものみたいです。&lt;/p&gt;

&lt;p&gt;かなりいろいろな事ができ、使いやすいように作られていますが、&lt;br /&gt;
ブラウザから制御するのはかなり苦労します。
ですが、Node.jsで実行する前提ならば、&lt;br /&gt;
簡単でいろいろなことができるため最適だと思います。&lt;/p&gt;

&lt;h1 id=&#34;serialport-server:b54319c1aa56c9cb7b2ee92a8a3c9010&#34;&gt;Serialport-server&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://shokai.github.io/serialport-server/&#34;&gt;http://shokai.github.io/serialport-server/&lt;/a&gt;&lt;br /&gt;
RubyからArduinoにアクセスし、その結果を返すサーバです。&lt;br /&gt;
noduinoに比べるとできることは少ないですが、&lt;br /&gt;
サンプルがちゃんと動き、Webブラウザから簡単に値がとれそうです。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
というわけで、ブラウザからArduinoを制御する場合は、&lt;br /&gt;
Serialport-serverが良さそうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavascriptでオプションのパースをするOptparse-js</title>
      <link>http://localhost:1313/blog/2014/08/26/optparse/</link>
      <pubDate>Tue, 26 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/26/optparse/</guid>
      <description>

&lt;p&gt;&lt;code&gt;find /tmp -name core -type f -print&lt;/code&gt;
のように、渡されたオプションを解析するのはよく行うことのため、&lt;br /&gt;
各言語でそれをやってくれるライブラリが作られています。&lt;/p&gt;

&lt;p&gt;javascriptでそれにあたるのがOptparse-jsですが、&lt;br /&gt;
使い方がちょっと独特です。&lt;/p&gt;

&lt;h1 id=&#34;インストール:69991f4bc87acfac541f5b8b32cae170&#34;&gt;インストール&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jfd/optparse-js&#34;&gt;https://github.com/jfd/optparse-js&lt;/a&gt;からどうぞ。&lt;br /&gt;
npmにも登録されているので、node.jsからも簡単に使えます。&lt;/p&gt;

&lt;h1 id=&#34;使い方:69991f4bc87acfac541f5b8b32cae170&#34;&gt;使い方&lt;/h1&gt;

&lt;h2 id=&#34;オプション指定:69991f4bc87acfac541f5b8b32cae170&#34;&gt;オプション指定&lt;/h2&gt;

&lt;p&gt;どのようなオプションを宇受け取るかは配列で定義します。&lt;br /&gt;
なお、短縮形も同時に定義できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var options = [
  [&amp;quot;-n&amp;quot;, &amp;quot;--name FILENAME&amp;quot;, &amp;quot;filename&amp;quot;],
  [&amp;quot;-t&amp;quot;, &amp;quot;--type TYPE&amp;quot;, &amp;quot;type&amp;quot;]
  ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、filenameを受け取る-nもしくは&amp;ndash;nameと、&lt;br /&gt;
typeを受け取る-tもしくは&amp;ndash;typeを定義しています。&lt;/p&gt;

&lt;p&gt;この配列をOptionParserに渡してパーサー用オブジェクトを受け取ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var parser = new optparse.OptionParser(options);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;オプション処理:69991f4bc87acfac541f5b8b32cae170&#34;&gt;オプション処理&lt;/h2&gt;

&lt;p&gt;オプションを受け取ったときの処理は、パーサーオブジェクトに関数を渡して登録します。&lt;br /&gt;
第一引数にオプション名、第二引数にそのオプションがあったときの処理を渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parser.on(&amp;quot;name&amp;quot;, function(opt, value) {
  parameter[&amp;quot;name&amp;quot;] = filename;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パース実行:69991f4bc87acfac541f5b8b32cae170&#34;&gt;パース実行&lt;/h2&gt;

&lt;p&gt;パーサーオブジェクトのparseメソッドでパースを実行できます。
ただし、スペースを自分で区切ってはくれないため、&lt;br /&gt;
先に配列に分けておく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parser.parse(command_str.split(&amp;quot; &amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(勝手にオプション足したり、区切り文字を自由に設定できる、こうしていると思われます)&lt;/p&gt;

&lt;h1 id=&#34;サンプルコード:69991f4bc87acfac541f5b8b32cae170&#34;&gt;サンプルコード&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var optparse = require(&#39;optparse&#39;);


var command_str = &amp;quot;-name core -type f&amp;quot;;

var options = [
  [&amp;quot;-n&amp;quot;, &amp;quot;--name FILENAME&amp;quot;, &amp;quot;filename&amp;quot;],
  [&amp;quot;-t&amp;quot;, &amp;quot;--type TYPE&amp;quot;, &amp;quot;type&amp;quot;]
  ];

var parser = new optparse.OptionParser(options);

parameter = {};

parser.on(&amp;quot;name&amp;quot;, function(opt, value) {
  parameter[&amp;quot;name&amp;quot;] = filename;
});

parser.on(&amp;quot;type&amp;quot;, function(opt, value) {
  parameter[&amp;quot;type&amp;quot;] = value;
});

parser.parse(command_str.split(&amp;quot; &amp;quot;));

console.log(parameter);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mocha&#43;chai&#43;sinsonでテストを書く為に必要な最低限の知識</title>
      <link>http://localhost:1313/blog/2014/08/22/mocha-test/</link>
      <pubDate>Fri, 22 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/22/mocha-test/</guid>
      <description>

&lt;h1 id=&#34;まとめ:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Mochaではrspecっぽい感じにテストが書ける&lt;/li&gt;
&lt;li&gt;ただし、done()を呼ぶ必要がある等、細かい部分に差異がある&lt;/li&gt;
&lt;li&gt;sinonにはいろいろ便利機能がある&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mochaの使い方:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;Mochaの使い方&lt;/h1&gt;

&lt;p&gt;coffeescriptを前提にしています。&lt;/p&gt;

&lt;h2 id=&#34;テストの書き方:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;テストの書き方&lt;/h2&gt;

&lt;p&gt;Mochaのテストは以下のように、itにテスト内容を書いた関数を渡し、&lt;br /&gt;
そのitを呼び出す関数をdescribeに渡すしようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;describe &amp;quot;test root&amp;quot;, -&amp;gt;
      it &amp;quot;name&amp;quot;, (done) -&amp;gt;
        assert.equal getUserName, &amp;quot;user&amp;quot;
        done()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、it関数では必ずdone()を呼び出す必要があります。&lt;br /&gt;
これを呼ばない場合は終了を待ち続け、&lt;br /&gt;
一定時間後にタイムアウトしてテストが失敗した扱いになります。&lt;/p&gt;

&lt;h2 id=&#34;beforeの使い方:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;beforeの使い方&lt;/h2&gt;

&lt;p&gt;rspecのbeforeにあたるものは、beforeEachになります。&lt;br /&gt;
 なお、変数を他のブロックに渡したい場合、&lt;br /&gt;
 以下のようにdescribeの中に変数名を書いておいて、&lt;br /&gt;
 beforeEachのなかで設定する必要があるみたいです。&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/20584233/mocha-pass-variable-to-the-next-test&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;describe &amp;quot;test&amp;quot;, -&amp;gt;
  room_name = undefined


  beforeEach (done) -&amp;gt;
    room_name = &amp;quot;test_room&amp;quot;

    done()

  describe &amp;quot;functions&amp;quot;, -&amp;gt;
      it &amp;quot;executeNoteShow&amp;quot;, (done) -&amp;gt;
        assert.equal getRoomName(room_name), room_name
        done()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pendingテストの作り方:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;pendingテストの作り方&lt;/h2&gt;

&lt;p&gt;テストの用意はしたけど、とりあえずpendingにしておきたい場合は二通りの方法があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;  describe &amp;quot;functions&amp;quot;, -&amp;gt;
      it &amp;quot;pending test&amp;quot; // 関数を渡さない場合


      // it.skipの場合、引数を渡しても実行されずにスキップする
      it.skip &amp;quot;pending test 2&amp;quot;, -&amp;gt;
          done()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;外部ファイル読み込み:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;外部ファイル読み込み&lt;/h2&gt;

&lt;p&gt;test.coffeeで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;class Test
  なんかいろいろ
module.exports.Test = Test

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、クラスを宣言し、module.exportsに代入します。
その後、使いたいファイル側で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;Test = require(&#39;../src/test.coffee&#39;).Test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと、以降Testでそのクラスが呼び出せます。&lt;/p&gt;

&lt;p&gt;#chaiの使い方&lt;/p&gt;

&lt;h2 id=&#34;assertを使う:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;assertを使う&lt;/h2&gt;

&lt;p&gt;前述のテストではassertを使っていますが、Mochaにはassertは入っていないため、&lt;br /&gt;
別ライブラリのchaiを読み込む必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;global.assert = require(&amp;quot;chai&amp;quot;).assert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、 assert.equalや assert.notEqualが使えます。&lt;/p&gt;

&lt;h1 id=&#34;sinonの使い方:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;sinonの使い方&lt;/h1&gt;

&lt;h2 id=&#34;mockやstubを使う:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;mockやstubを使う&lt;/h2&gt;

&lt;p&gt;Mochaにはmockやstubの為の物は含まれていないので、&lt;br /&gt;
今度はsinonを読み込む必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;global.sinon = require(&#39;simon&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い方は以下の通りです&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;    // robot.brainがstubになる
    robot = new Object()
    robot.brain = sinon.stub()


    // hubot_note.executeNoteShowを置き換え、
    // hubot_note.executeMessage実行時に、
    // &amp;quot;test&amp;quot;, null, nullの引数で一回だけ実行されたかをチェックする

    spy = sinon.spy(hubot_note, &amp;quot;executeNoteShow&amp;quot;)
    spy.withArgs(&amp;quot;test&amp;quot;, null, null)
    response = hubot_note.executeMessage(room_name, &amp;quot;hubot note show&amp;quot;)
    assert.ok spy.withArgs(&amp;quot;test&amp;quot;, null, null).calledOnce

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;時間変更の仕方:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;時間変更の仕方&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;new Date()&lt;/code&gt;などによって日付がちゃんと設定されたかどうかを確認したい場合、&lt;br /&gt;
グローバルなDate()部分を置き換える必要があります。&lt;/p&gt;

&lt;p&gt;…というのはよくあることなので、sinon側で既に用意されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;@clock = sinon.useFakeTimers(0,
  &amp;quot;setTimeout&amp;quot;, &amp;quot;clearTimeout&amp;quot;,
  &amp;quot;setInterval&amp;quot;, &amp;quot;clearInterval&amp;quot;, &amp;quot;Date&amp;quot;)`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、以降のDateコマンドは第一引数で指定した0(1970年1月1日0時0分0秒)を必ず返すようになるため、&lt;br /&gt;
この時間かどうかをチェックすれば大丈夫です。&lt;br /&gt;
また、以下のように戻り値のオブジェクトのtickメソッドにより、&lt;br /&gt;
指定したミリ秒だけ時間を進めることもできます。&lt;br /&gt;
&lt;code&gt;@clock.tick(3600000)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;sinonのその他の機能:3bae98bb6aa9abe8f0b8472a1492cace&#34;&gt;sinonのその他の機能&lt;/h2&gt;

&lt;p&gt;sinonに関しては他にもいろいろ有用なものがあります。&lt;br /&gt;
ちょっと古いですが、以下のmixiさんのブログ記事は参考になると思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alpha.mixi.co.jp/2011/10798/&#34;&gt;http://alpha.mixi.co.jp/&lt;sup&gt;2011&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10798&lt;/sub&gt;/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IntelliJ IDEAで node.jsとmochaを使ってテストする</title>
      <link>http://localhost:1313/blog/2014/08/21/intellij-node/</link>
      <pubDate>Thu, 21 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/21/intellij-node/</guid>
      <description>

&lt;p&gt;node.js+mocha+coffeescriptな環境で開発をしていたところ、&lt;br /&gt;
IntelliJ IDEAの設定方法が調べても無かったのでメモ。&lt;/p&gt;

&lt;h1 id=&#34;node-jsプラグインのインストール:e3fb602c4f14f4e7f9a5efde53d66faa&#34;&gt;Node.jsプラグインのインストール&lt;/h1&gt;

&lt;p&gt;Node.jsプラグインは公式から提供されています。&lt;br /&gt;
そのため、IntelliJ のPreferences からPluginsを選び、&lt;br /&gt;
NodeJSプラグインを選択するだけでインストール出来ます。&lt;/p&gt;

&lt;h1 id=&#34;ビルド設定:e3fb602c4f14f4e7f9a5efde53d66faa&#34;&gt;ビルド設定&lt;/h1&gt;

&lt;p&gt;以下の画像の通りです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/blog/2014/2014-08-21-intellij-node.png&#34; alt=&#34;設定画像&#34; /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node interpreter&lt;br /&gt;
node.jsの実行ファイルの位置を設定します。&lt;/li&gt;
&lt;li&gt;working directory&lt;br /&gt;
対象のディレクトリ&lt;/li&gt;
&lt;li&gt;Mocha package&lt;br /&gt;
Mochaの実行ファイルの位置&lt;/li&gt;
&lt;li&gt;Extra Mocha options&lt;br /&gt;
Mochaの設定を指定します
詳しくは後述&lt;/li&gt;
&lt;li&gt;Test Directory&lt;br /&gt;
Mochaのテストが入っている場所&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mochaのオプション:e3fb602c4f14f4e7f9a5efde53d66faa&#34;&gt;Mochaのオプション&lt;/h1&gt;

&lt;p&gt;私の環境では主に次のような設定をしています、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;coffeescriptを利用している&lt;/li&gt;
&lt;li&gt;spec形式で出力&lt;/li&gt;
&lt;li&gt;共通で読み込むファイルがある&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これは、以下のオプションを入れることで実現できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--compilers
coffee:coffee-script/register
--reporter
spec
--require
coffee-script
--require
test/test_helper.coffee
--colors
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;問題点:e3fb602c4f14f4e7f9a5efde53d66faa&#34;&gt;問題点&lt;/h1&gt;

&lt;p&gt;以上で設定は終わりですが、いくつか問題点があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;デバッガが動かない&lt;br /&gt;
coffeescriptから変換してるので、&lt;br /&gt;
ブレークポイントがうまく動きません&lt;/li&gt;
&lt;li&gt;エラーになったテストに飛べない&lt;br /&gt;
テストがエラーになったとしても、そのテストの位置に飛ぶ機能がありません。&lt;br /&gt;
最も、IDEを使わずに開発している時と同じく、&lt;br /&gt;
テストメッセージを頼りにテストファイルに移動すればいいので、&lt;br /&gt;
大きな問題ではありませんが。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pixivの検索フィルタ作った</title>
      <link>http://localhost:1313/blog/2014/08/20/pixiv-follow-filter/</link>
      <pubDate>Wed, 20 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/20/pixiv-follow-filter/</guid>
      <description>

&lt;p&gt;まとめ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pixivの検索は全ユーザから&lt;/li&gt;
&lt;li&gt;○○が好きな新しいユーザを探したい時に既にフォローしている人はノイズになる&lt;/li&gt;
&lt;li&gt;検索結果からフォローしている人を非表示にする拡張作った&lt;/li&gt;
&lt;li&gt;DLは&lt;a href=&#34;https://chrome.google.com/webstore/detail/pixivfollowerfilter/oopgkhmlkjnooncplailjfanlichdalp?hl=ja&amp;amp;authuser=1&#34;&gt;ここ&lt;/a&gt;から&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;pixivのイラスト検索でフォロワーを除外できない:fb50430d1383f76f5555f2225e4e2273&#34;&gt;Pixivのイラスト検索でフォロワーを除外できない&lt;/h1&gt;

&lt;p&gt;Pixivでイラスト検索をした場合、全ユーザを対象に検索が行われるため、&lt;br /&gt;
検索結果にフォローしてる人とそうでない人が交じります。&lt;/p&gt;

&lt;p&gt;私の場合、&lt;a href=&#34;http://www.pixiv.net/bookmark_new_illust.php&#34;&gt;フォロー新着作品&lt;/a&gt;を全てチェックしているため、&lt;br /&gt;
検索をする場合は、このイラスト書いてる新しい人を見つけたい！といった目的で行うことがほとんどです。&lt;/p&gt;

&lt;p&gt;そのため、フォロワー以外からの検索を行いたいのですが、&lt;br /&gt;
残念ながらPixivにそのような機能はありませんでした。&lt;/p&gt;

&lt;p&gt;というわけで、Chrome拡張で実現しました。&lt;/p&gt;

&lt;h1 id=&#34;フィルタの基本機能:fb50430d1383f76f5555f2225e4e2273&#34;&gt;フィルタの基本機能&lt;/h1&gt;

&lt;p&gt;DLは&lt;a href=&#34;https://chrome.google.com/webstore/detail/pixivfollowerfilter/oopgkhmlkjnooncplailjfanlichdalp?hl=ja&amp;amp;authuser=1&#34;&gt;ここ&lt;/a&gt;から。&lt;/p&gt;

&lt;p&gt;検索結果にはユーザのユニークIDが含まれているため、&lt;br /&gt;
自分のフォローしている人と一致していれば非表示にしています。&lt;/p&gt;

&lt;p&gt;また、毎回通信するのは無駄が多いため、&lt;br /&gt;
事前にフォローしている人のIDをローカルに保存し、そこから読み出しています。&lt;br /&gt;
そのため、ポップアップウィンドウから定期的にデータの更新をする必要があります。&lt;/p&gt;

&lt;h1 id=&#34;ソースコード:fb50430d1383f76f5555f2225e4e2273&#34;&gt;ソースコード&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ota42y/pixiv_follower_filter&#34;&gt;https://github.com/ota42y/pixiv_follower_filter&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>chrome extensionでデータを保存する</title>
      <link>http://localhost:1313/blog/2014/08/17/local-storage/</link>
      <pubDate>Sun, 17 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2014/08/17/local-storage/</guid>
      <description>

&lt;p&gt;Chrome拡張でデータを保存しようとした場合に、&lt;br /&gt;
最も簡単に扱えるのが、localStorageです。&lt;/p&gt;

&lt;h1 id=&#34;manifest-jsonの設定:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;manifest.jsonの設定&lt;/h1&gt;

&lt;p&gt;manifest.jsonに以下のパーミッションを追加してください&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;permissions&amp;quot;: [
    &amp;quot;storage&amp;quot;,
    &amp;quot;unlimitedStorage&amp;quot;
  ],

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;使い方:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;使い方&lt;/h1&gt;

&lt;p&gt;localStorageという辞書型の変数が定義されるので、&lt;br /&gt;
それに対して読み書きを行うだけで大丈夫です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;localStorage[‘data’] = ‘aaa&#39;
var data = localStorage[‘data’]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;注意点:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;注意点&lt;/h1&gt;

&lt;h2 id=&#34;保存形式の制約:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;保存形式の制約&lt;/h2&gt;

&lt;p&gt;この方法で保存できるのは文字列だけになります。&lt;br /&gt;
true/falseを保存しても文字列として出てきますし、&lt;br /&gt;
オブジェクトを入れても正しく保存されません。&lt;/p&gt;

&lt;p&gt;このような場合、JSON.stringifyとJSON.parseを使い、&lt;br /&gt;
JSONに変換して保存すると解決します。&lt;/p&gt;

&lt;h2 id=&#34;読み出せる場所の制約:bd0bcec2c9ce117e634be75ae1170102&#34;&gt;読み出せる場所の制約&lt;/h2&gt;

&lt;p&gt;localStorageはページごとに保存するデータがわかれているため、&lt;br /&gt;
読み書きは同じ場所で行う必要があります。&lt;/p&gt;

&lt;p&gt;基本的にはbackgruond.jsで読み書きを行い、&lt;br /&gt;
content_scriptsやpopupからbackground.jsを呼び出すのがいいと思います。&lt;/p&gt;

&lt;p&gt;popupからは以下のように、background.jsの関数を簡単に呼び出すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// background.jsのgetDataを呼び出す
var data = chrome.extension.getBackgroundPage().getData();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;content_scriptsからは直接アクセスできないため、&lt;br /&gt;
メッセージを通して呼び出す必要があり、少々面倒です。&lt;/p&gt;

&lt;p&gt;まず、background側にメッセージ受け取りと、コールバックを定義します。&lt;br /&gt;
content_scriptsからのメッセージ内容がrequestに入っているので、&lt;br /&gt;
それによって処理を分けています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
  if (request.method == &amp;quot;getUser&amp;quot;){
    sendResponse({user_id: localStorage[request.user_id]});
  }else{
    sendResponse({});
  }
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;content_scriptから呼び出す場合は以下のように、&lt;br /&gt;
データとコールバックを渡します。&lt;br /&gt;
受け取り側でsendResponse()を読んだときの引数がresponseに入るので、&lt;br /&gt;
それを利用してデータを取り出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;chrome.runtime.sendMessage({method: &amp;quot;getUser&amp;quot;, user_id: user_id},
 function(response) {
  if(response.user_name){
    console.log(response.user_name);
  }
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>