<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins on おおたの物置</title>
    <link>http://ota42y.com/tags/jenkins/</link>
    <description>Recent content in Jenkins on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Fri, 27 Feb 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://ota42y.com/tags/jenkins/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JenkinsをHTTP経由で叩く</title>
      <link>http://ota42y.com/blog/2015/02/27/jenkins-remote-api/</link>
      <pubDate>Fri, 27 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/02/27/jenkins-remote-api/</guid>
      <description>

&lt;h1 id=&#34;まとめ:af624862a939b6a21fcbc09ac950f3c4&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;JenkinsはWebベースのUI

&lt;ul&gt;
&lt;li&gt;操作の敷居が低い&lt;/li&gt;
&lt;li&gt;使い込むと使いづらくなる&lt;/li&gt;
&lt;li&gt;反応速度&lt;/li&gt;
&lt;li&gt;複数のビルド実行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Remote access API

&lt;ul&gt;
&lt;li&gt;HTTP経由でJobを実行できる&lt;/li&gt;
&lt;li&gt;ページ表示を待たなくていいため高速&lt;/li&gt;
&lt;li&gt;プログラムから実行可能&lt;/li&gt;
&lt;li&gt;ただし、Jenkinsの仕様上、実行したビルドのビルド番号は解らない&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;jenkinsのjob実行は大変:af624862a939b6a21fcbc09ac950f3c4&#34;&gt;JenkinsのJob実行は大変&lt;/h1&gt;

&lt;p&gt;JenkinsはWebブラウザを使ってGUIで操作するため、&lt;br /&gt;
操作の敷居が低く、簡単に扱えるようになっています。&lt;/p&gt;

&lt;p&gt;ですが、ブラウザやJenkins本体の状態によってはとても遅くなってしまい、&lt;br /&gt;
ページを切り替えるのに3，4秒待つといった状態まで遅くなると、&lt;br /&gt;
ビルドをするのがとても辛くなります。&lt;/p&gt;

&lt;p&gt;また、パラメータの組み合わせの分だけビルドしようとすると、&lt;br /&gt;
さらに辛くなってしまいます。&lt;/p&gt;

&lt;p&gt;このような場合に、Jenkinsに用意されているRemote access APIを使うことで、&lt;br /&gt;
Jenkinsをプログラムから制御でき、反応の遅さに悩まされたり、&lt;br /&gt;
パラメータの数だけクリックをする必要性から逃れられます。&lt;/p&gt;

&lt;h1 id=&#34;remote-access-api:af624862a939b6a21fcbc09ac950f3c4&#34;&gt;Remote access API&lt;/h1&gt;

&lt;p&gt;詳しくはこちら&lt;br /&gt;
&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Remote+access+API&#34;&gt;https://wiki.jenkins-ci.org/display/JENKINS/Remote+access+API&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Build&#34;&gt;https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Build&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要するに、パラメータが無い場合は&lt;br /&gt;
&lt;code&gt;http://HOST/job/JOB_NAME/build&lt;/code&gt;
に、ある場合は&lt;br /&gt;
&lt;code&gt;http://HOST/job/JOB_NAME/buildWithParameters&lt;/code&gt;
にPOSTで投げるとビルドできます。&lt;/p&gt;

&lt;p&gt;パラメータの投げ方はフォームデータとしてでもいいですし、&lt;br /&gt;
&lt;code&gt;http://HOST/job/JOB_NAME/buildWithParameters?PARAMETER=Value&lt;/code&gt;
のように、URLに直接入れても大丈夫のようです。&lt;/p&gt;

&lt;h1 id=&#34;サンプルスクリプト:af624862a939b6a21fcbc09ac950f3c4&#34;&gt;サンプルスクリプト&lt;/h1&gt;

&lt;p&gt;3*3=9種類のビルドを一気に実行するスクリプトです&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;open-uri&#39;
require &#39;net/http&#39;

platforms = [&amp;quot;ios&amp;quot;,  &amp;quot;android&amp;quot;, &amp;quot;windows&amp;quot;]
settings =  [&amp;quot;debug&amp;quot;,&amp;quot;release&amp;quot;, &amp;quot;store&amp;quot;]

platforms.product(settings).each do |platform, setting|
  params = {:PLATFORM =&amp;gt; platform, :SETTING =&amp;gt; setting}
  p params

  url = URI.parse(&#39;http://HOST/job/JOB_NAME/buildWithParameters&#39;)
  req = Net::HTTP::Post.new(url.path)
  req.basic_auth &#39;NAME&#39;, &#39;PASSWORD&#39;
  req.set_form_data(params)
  res = Net::HTTP.new(url.host, url.port).start {|http| http.request(req) }
  case res
  when Net::HTTPSuccess, Net::HTTPRedirection
    p &amp;quot;OK&amp;quot;
  else
    res.value
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;問題点:af624862a939b6a21fcbc09ac950f3c4&#34;&gt;問題点&lt;/h1&gt;

&lt;p&gt;Jenkinsの仕様上、キューを入れた段階でビルド番号が確定しません。&lt;br /&gt;
そのため、実行したビルドが何番のビルドとして登録されたかをレスポンスから知ることは出来ません。ss&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jenkins Workflow Pluginでリポジトリ内のスクリプトを読み込む時の注意点</title>
      <link>http://ota42y.com/blog/2015/02/11/jenkins-workflow/</link>
      <pubDate>Wed, 11 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/02/11/jenkins-workflow/</guid>
      <description>

&lt;h1 id=&#34;まとめ:0ccb30a040a233a026556ed14d67937d&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ブランチをパラメーターにするとスクリプトを読めない

&lt;ul&gt;
&lt;li&gt;中身ではなく変数名のブランチを探しに行く&lt;/li&gt;
&lt;li&gt;多分バグ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ファイルから読み込むるスクリプトを書けば解決

&lt;ul&gt;
&lt;li&gt;公式のflow.groovyを参考に&lt;/li&gt;
&lt;li&gt;変数を使おうとすると面倒&lt;/li&gt;
&lt;li&gt;java.io.Serializableを実装する必要あり&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;gitリポジトリ内のスクリプトを指定できない:0ccb30a040a233a026556ed14d67937d&#34;&gt;gitリポジトリ内のスクリプトを指定できない&lt;/h1&gt;

&lt;p&gt;(以下に用意されているdocker上のJenkinsで確認しました)&lt;br /&gt;
&lt;a href=&#34;https://github.com/jenkinsci/workflow-plugin/blob/master/demo/README.md&#34;&gt;https://github.com/jenkinsci/workflow-plugin/blob/master/demo/README.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Workflow Pluginでは、リポジトリ内のgroovyスクリプトを読み込んで実行する機能があります。&lt;br /&gt;
この機能を使うことで、リポジトリの内容とそれに対応するビルド手順を同時にバージョン管理出来るため、&lt;br /&gt;
ビルド手順の変更がとてもやりやすくなります。&lt;/p&gt;

&lt;p&gt;ですが残念ながら、パラメータで指定したブランチをチェックアウトして読み込むと、以下のエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; git config remote.origin.url /var/lib/jenkins/workflow-plugin-pipeline-demo # timeout=10
Fetching upstream changes from /var/lib/jenkins/workflow-plugin-pipeline-demo
&amp;gt; git --version # timeout=10
&amp;gt; git -c core.askpass=true fetch --tags --progress /var/lib/jenkins/workflow-plugin-pipeline-demo
+refs/heads/*:refs/remotes/origin/*
&amp;gt; git rev-parse origin/$BRANCH_NAME^{commit} # timeout=10
&amp;gt; git rev-parse $BRANCH_NAME^{commit} # timeout=10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パラメータの内容ではなく、パラメータの名前そのものを探しに行っており、おそらくバグと思われます。&lt;br /&gt;
通常のJobでGit Pluginを使うと問題なくパラメータ指定が出来るため、Workflowのバグと思われます。&lt;/p&gt;

&lt;p&gt;このバグは、Jenkinsでは事前に設定した特定ブランチしかビルドしない場合は問題ありません。&lt;br /&gt;
ですが、様々なブランチで実行する可能性がある場合、JenkinsのJob設定にスクリプトを書かなければならず、&lt;br /&gt;
ビルド手順自体の管理が大変になります。&lt;/p&gt;

&lt;p&gt;このような場合、スクリプトをロードして実行するスクリプトをJobに設定することで、&lt;br /&gt;
指定したブランチからスクリプトを読み込んで実行できます。&lt;/p&gt;

&lt;h1 id=&#34;スクリプトをロードして実行するスクリプト:0ccb30a040a233a026556ed14d67937d&#34;&gt;スクリプトをロードして実行するスクリプト&lt;/h1&gt;

&lt;p&gt;(公式のdockerにも&lt;a href=&#34;https://github.com/jenkinsci/workflow-plugin-pipeline-demo/blob/master/flow.groovy&#34;&gt;スクリプト&lt;/a&gt;がありますが、より簡単化したもので説明します)&lt;/p&gt;

&lt;p&gt;以下のようなスクリプトをリポジトリのルートに起きます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// build.groovy
def build(){
  node(&amp;quot;slave&amp;quot;) {
    git url: ‘RIPOSITORY_URL&#39;, branch: “$BRANCH_NAME&amp;quot;
    sh “rake build&amp;quot;
  }
}
return this
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jobには以下のスクリプトを書きます&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def flow
node(&amp;quot;master&amp;quot;) {
    git url: ‘RIPOSITORY_URL&#39;, branch: “$BRANCH_NAME&amp;quot;
    flow = load &#39;flow.groovy&#39;
}
flow.build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;loadは指定したパスのgroovyスクリプトを読み込み、returnしたオブジェクトを返します。&lt;br /&gt;
そのため、これでリポジトリ内のファイルをロードして実行することが出来ます。&lt;br /&gt;
また、buildメソッドをnodeの外側で実行することで、ビルド中はmasterのキューを開けておくことが出来ます。&lt;/p&gt;

&lt;h1 id=&#34;ロード時に変数を保存したい場合:0ccb30a040a233a026556ed14d67937d&#34;&gt;ロード時に変数を保存したい場合&lt;/h1&gt;

&lt;p&gt;上記の方式の場合、masterにcloneしてその後にslave上に再度cloneしてビルドを始めています。&lt;br /&gt;
slaveの選択を凝らない場合は問題ないですが、リリースビルド専用マシンがあったり、&lt;br /&gt;
特定のミドルウェアを使うビルドの場合など、slaveの選択をパラメータによって切り替えたい場合があります。&lt;/p&gt;

&lt;p&gt;パラメータだけで決定できる場合は問題ありませんが、リポジトリ内のファイルを読み込む必要がある場合、&lt;br /&gt;
上記のスクリプトの場合でいうところの、node(&amp;ldquo;master&amp;rdquo;)内で処理しなければなりません。&lt;br /&gt;
当然Job側にそれを書くとメンテが大変になるため、flow.groovy内に書く必要があります。&lt;/p&gt;

&lt;p&gt;このような場合、groovyスクリプトの戻り値で独自クラスを返すことで解決できます。&lt;/p&gt;

&lt;h1 id=&#34;load関数の戻り値で独自クラスを返す:0ccb30a040a233a026556ed14d67937d&#34;&gt;load関数の戻り値で独自クラスを返す&lt;/h1&gt;

&lt;p&gt;Jenkinsから以下のようなgroovyスクリプトを読み込むことで、slaveの選択も柔軟にできるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def buildSlave(slaveName){
  slave(slaveName){
    sh &amp;quot;echo ’slave&#39;&amp;quot;
  }
}

class FlowStruct implements java.io.Serializable{
  def slaveName
  def flow
  public void build(){
    flow.buildSlave(slaveName)
  }
}

f = new FlowStruct()
f.slaveName = readFile(“settings/config_${SETTING}&amp;quot;).trim()
f.flow = this

return f;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;load関数では通常の文はすべて実行されるため、FlowStruct()以降が実行されてから関数が終了します。&lt;br /&gt;
また、戻り値は固定ではないため、上記のように独自のクラスを作成して返すことができます。&lt;br /&gt;
この際、戻り値はjava.io.Serializableを実装している必要がありますのでご注意ください。&lt;/p&gt;

&lt;p&gt;これで、複雑な設定をしていたとしても、すべてリポジトリ内のスクリプトで処理することが出来ます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jenkins Workflow Pluginで複数slaveを扱うのが楽になる</title>
      <link>http://ota42y.com/blog/2015/02/10/workflow-plugin/</link>
      <pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/02/10/workflow-plugin/</guid>
      <description>

&lt;h1 id=&#34;まとめ:ccf6631e819df9368a47b40de1b4ff36&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Jenkinsはjob単位でしかノードに割り振れない

&lt;ul&gt;
&lt;li&gt;複数ノードで分散ビルドするには設定を駆使する必要がある&lt;/li&gt;
&lt;li&gt;結果としてjobの数が増えて管理コストが増大する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Workflow Pluginで大幅に改善する

&lt;ul&gt;
&lt;li&gt;スクリプトからノードを指定してコマンドを実行できる&lt;/li&gt;
&lt;li&gt;複数のjobを組み合わせていたのが一つのスクリプトですむ&lt;/li&gt;
&lt;li&gt;スクリプトをVCSに入れればビルド設定のバージョン管理も可能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;複数ノードをコントロールするのは難しい:ccf6631e819df9368a47b40de1b4ff36&#34;&gt;複数ノードをコントロールするのは難しい&lt;/h1&gt;

&lt;p&gt;Jenkinsを一つのノードで運用している場合はそれほど問題になりませんが、&lt;br /&gt;
複数のノードで、jobの一部の部分だけを別のノードで実行するなど、&lt;br /&gt;
ある程度複雑な分散をやろうとすると、Jenkins本体の機能では不足してきます。&lt;/p&gt;

&lt;p&gt;このような問題に対して、これまではBuild Flow Pluginを使う事で解決が可能でしたが、&lt;br /&gt;
Workflow Pluginを使う事で、さらに簡単に解決することが出来ます。&lt;/p&gt;

&lt;h1 id=&#34;build-flow-pluginの問題点:ccf6631e819df9368a47b40de1b4ff36&#34;&gt;Build Flow Pluginの問題点&lt;/h1&gt;

&lt;p&gt;Build Flow Pluginは基本的に複数の下流ビルドを管理するために作られているため、&lt;br /&gt;
処理を分けようとするとjobの数が増加していきます。&lt;/p&gt;

&lt;p&gt;例えばネイティブアプリのビルドのようなCPUパワーを使う処理と、パワーを使わないアップロード処理がある場合、&lt;br /&gt;
一つのノードで全てやるよりも、非力なサーバを確保してアップロード処理をそちらで実行した方が、&lt;br /&gt;
ビルド用のノードはビルドに専念でき、無駄なくjobを実行できます。&lt;br /&gt;
(また、masterとビルドを同じノードでやるとJenkins本体の処理が遅くなるため、分割する利点は他にもあります)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ota42y.com/images/blog/2015/2015-02-10-master-slave.jpg&#34; alt=&#34;分割イメージ&#34; /&gt;
&lt;br /&gt;
(上段のup#4はup#3の間違いです…)&lt;/p&gt;

&lt;p&gt;ビルドが数十分、数時間かかるような巨大な処理の場合、&lt;br /&gt;
処理を分散することで稼げる時間はかなりのものになります。&lt;/p&gt;

&lt;p&gt;従来では分割する作業を別のjobにし、かつBuild Flow Plugin用のjobを作る必要があります。&lt;br /&gt;
さらに、ファイルの受け渡しもできないため、成果物として保存して、&lt;br /&gt;
次のjobは前のjobの特定のビルド番号の成果物を取り出す…といった風になります。&lt;/p&gt;

&lt;p&gt;jobの数が増えると管理も大変ですし、使う方もどれを使えば良いのか解らなくなります。&lt;br /&gt;
ここで、Workflow Pluginを使うことで大きく改善することが出来ます。&lt;/p&gt;

&lt;h1 id=&#34;workflow-pluginを使ったビルド:ccf6631e819df9368a47b40de1b4ff36&#34;&gt;Workflow Pluginを使ったビルド&lt;/h1&gt;

&lt;p&gt;Workflow Pluginでは、slaveを選択してコマンドを実行、&lt;br /&gt;
特定のファイルを別のslaveにコピーして処理を実行ということががスクリプトで書けます。&lt;/p&gt;

&lt;p&gt;例えば以下のように書くことで、masterでファイルを生成してslaveで実行、&lt;br /&gt;
その後結果をmasterにコピーしてアップロードみたいな事が出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;node(&amp;quot;master&amp;quot;){
  sh &amp;quot;rake config&amp;quot;
  archive &amp;quot;config.yml&amp;quot;
}

node(&amp;quot;slave&amp;quot;){
  unarchive mapping: [&#39;config.yml&#39; : &#39;./&#39;]
  sh &amp;quot;rake build&amp;quot;
  archive &amp;quot;result.zip&amp;quot;
}

node(&amp;quot;master&amp;quot;){
  unarchive mapping: [&#39;result.zip&#39; : &#39;.&#39;]
  sh &amp;quot;rake upload&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、複数平行してのビルド等も出来るため、Jenkinsで複数ノードを使って分散ビルドをしたい場合に、&lt;br /&gt;
一つのスクリプトで全てをコントロールできるため、とても重宝します。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>参加記録 Jenkins ユーザ・カンファレンス 2015 東京</title>
      <link>http://ota42y.com/blog/2015/01/11/jenkins-conference/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/11/jenkins-conference/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://build-shokunin.org/juc2015/&#34;&gt;Jenkins ユーザ・カンファレンス 2015 東京&lt;/a&gt;に参加しました。&lt;br /&gt;
&lt;a href=&#34;http://togetter.com/li/765735&#34;&gt;Togetterまとめ&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;発表まとめ:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;発表まとめ&lt;/h1&gt;

&lt;h2 id=&#34;アンケート結果:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;アンケート結果&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参加申し込み時のアンケート結果&lt;/li&gt;
&lt;li&gt;多くの人のjobの数が1〜数個程度&lt;/li&gt;
&lt;li&gt;Jenkins無くても生きていける人が30％ぐらい&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;思ったよりもみんなJenkinsを使い込んでいない印象&lt;/li&gt;
&lt;li&gt;アンケート結果は後日公開&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jenkinsプロジェクトの現状とワークフロー:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;Jenkinsプロジェクトの現状とワークフロー&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DotCiが良さそう

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/groupon/DotCi&#34;&gt;https://github.com/groupon/DotCi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jenkinsを他のCIサービスみたいにする&lt;/li&gt;
&lt;li&gt;Github限定&lt;/li&gt;
&lt;li&gt;設定をYAMLファイルで管理出来たりする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Workflow Pluginすごい

&lt;ul&gt;
&lt;li&gt;Build Flow Pluginをいっそう強化した版&lt;/li&gt;
&lt;li&gt;ビルドが失敗しても途中から再開とかも出来る&lt;/li&gt;
&lt;li&gt;乗り換えよう&lt;/li&gt;
&lt;li&gt;ただ、DSLを覚えたりと学習コストが高くなるので秘伝のタレ化の危険が&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jenkinsとseleniumの活用事例-試験自動化のプロジェクトへの導入:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;JenkinsとSeleniumの活用事例：試験自動化のプロジェクトへの導入&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;アジャイル開発だとイテレーション毎に試験項目は増えていくが、開発後半になるほど試験に割ける時間は減る

&lt;ul&gt;
&lt;li&gt;あるあるすぎる&lt;/li&gt;
&lt;li&gt;試験自動化で試験項目の消化にかかるコストを下げる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;スクリーンショットを撮って画像比較して変更検知

&lt;ul&gt;
&lt;li&gt;静的な画面なら効果的っぽい&lt;/li&gt;
&lt;li&gt;アニメーションする場合は撮るタイミングによりそうなので、目で比較かなぁ…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;テストケースの保守大変そう

&lt;ul&gt;
&lt;li&gt;ちょっと変わっただけで使えなくなるし&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jenkinsを使ったコンシューマゲームでのデプロイとテスト:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;Jenkinsを使ったコンシューマゲームでのデプロイとテスト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/swiftnest/jenkins-43394510&#34;&gt;http://www.slideshare.net/swiftnest/jenkins-43394510&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;圧縮して6GB、11万ファイルのプロジェクト

&lt;ul&gt;
&lt;li&gt;2プラットフォーム2言語にビルド&lt;/li&gt;
&lt;li&gt;これで中規模ぐらいと凄い世界が…

&lt;ul&gt;
&lt;li&gt;FFとかどんだけなんだろう…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;フルビルドに14時間かかる

&lt;ul&gt;
&lt;li&gt;リソースの事前処理に時間がかかる

&lt;ul&gt;
&lt;li&gt;リソース内での分岐処理が遅いため、全条件分のリソースを作る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;データを実機上でビルドする必要がある

&lt;ul&gt;
&lt;li&gt;携帯機は貧弱なので差分ビルドでも4時間かかったりする&lt;/li&gt;
&lt;li&gt;プラットフォームで互換性なし&lt;/li&gt;
&lt;li&gt;PS3はビッグエンディアン&lt;/li&gt;
&lt;li&gt;VITAはリトルエンディアン&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ファイルをパックするのでキャッシュが効かない

&lt;ul&gt;
&lt;li&gt;ファイルアクセス回数を減らすため必須&lt;/li&gt;
&lt;li&gt;全データを実機でパックするため6時間ぐらい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;頑張って並列化して5〜9時間ぐらいまで減らす

&lt;ul&gt;
&lt;li&gt;データの処理を4台で並列化

&lt;ul&gt;
&lt;li&gt;一台4時間ぐらいに短縮&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;テスト

&lt;ul&gt;
&lt;li&gt;テストフレームワークなど無い&lt;/li&gt;
&lt;li&gt;スモークテスト

&lt;ul&gt;
&lt;li&gt;特定ミッションに入れるかどうかをテスト&lt;/li&gt;
&lt;li&gt;引数で専用のミッションを始められるように

&lt;ul&gt;
&lt;li&gt;一定時間たったら終了させる&lt;/li&gt;
&lt;li&gt;正常終了しなかったらエラー&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;起動からスタート、終了までがちゃんと動くか&lt;/li&gt;
&lt;li&gt;リソースに問題ないか&lt;/li&gt;
&lt;li&gt;エフェクト再生チェック&lt;/li&gt;
&lt;li&gt;一定時間内に終わるか&lt;/li&gt;
&lt;li&gt;データが変換可能か&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;モンキーテスト

&lt;ul&gt;
&lt;li&gt;開始からエンディングまでの通しプレイAI&lt;/li&gt;
&lt;li&gt;良い感じに攻撃する

&lt;ul&gt;
&lt;li&gt;適当にボタン連打&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;適当に移動&lt;/li&gt;
&lt;li&gt;何回もゲームオーバーになったら無敵＆攻撃力１００倍&lt;/li&gt;
&lt;li&gt;メニュー操作テスト&lt;/li&gt;
&lt;li&gt;普通のUIテストっぽい&lt;/li&gt;
&lt;li&gt;長時間テスト特有のバグ発見に繋がる&lt;/li&gt;
&lt;li&gt;リソースの解放漏れ

&lt;ul&gt;
&lt;li&gt;携帯機はスリープできるので普通は電源を切らない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;問題点

&lt;ul&gt;
&lt;li&gt;作成やメンテナンスにコストがかかる&lt;/li&gt;
&lt;li&gt;ゆとりがある時期にどれだけ作れるか勝負&lt;/li&gt;
&lt;li&gt;チェックに時間かかる&lt;/li&gt;
&lt;li&gt;一日じゃ終わらない&lt;/li&gt;
&lt;li&gt;手動テストの置き換えにはならない&lt;/li&gt;
&lt;li&gt;テストのパターンが固定化されるため、外れた部分のバグは検知不可&lt;/li&gt;
&lt;li&gt;人の手のかかるテストを減らす効果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;おばかxfdコンテスト:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;おばかXFDコンテスト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;人は慣れる生き物

&lt;ul&gt;
&lt;li&gt;何度も通知してるとそのうち無視するようになる

&lt;ul&gt;
&lt;li&gt;エラーメールを迷惑フォルダに入れたり&lt;/li&gt;
&lt;li&gt;パトランプの上に被せたり&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;XFDによる通知で、慣れに逆らう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lt大会:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;LT大会&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Jenkinsを使った継続的Webセキュリティテスト

&lt;ul&gt;
&lt;li&gt;継続的にセキュリティテストを実施するVAddyの話

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://vaddy.net/ja/&#34;&gt;http://vaddy.net/ja/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ちゃんと専門家が監修しているという噂がTLに流れた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Jenkinsおじさん、お堅いメガバンクに就職

&lt;ul&gt;
&lt;li&gt;金融系企業でJenkinsが使われているだと(´･_･`)！！&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ちゃんと聞きたかったけど、時間が足りなくて終了…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Jenkinsおじさんと楽しい連携ツールたち

&lt;ul&gt;
&lt;li&gt;Deploygate、Slack、Gitlabの連携話
– だいたい似たようなことしてる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ゲーム業界の人がJenkinsさん3Dモデルで遊んでみた

&lt;ul&gt;
&lt;li&gt;Jenkinsの3Dモデルで遊んでる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CI”じゃない方”のJenkins

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/MiuraKatsu/ci-43396873&#34;&gt;http://www.slideshare.net/MiuraKatsu/ci-43396873&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CI以外の使い道&lt;/li&gt;
&lt;li&gt;cronの置き換え&lt;/li&gt;
&lt;li&gt;外部ツールの連携

&lt;ul&gt;
&lt;li&gt;ピタゴラジェンキンス&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;まとめ:6fcd8b087d02d0718ea7af307b5884dd&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Jenkins単体の話はなくって、Jenkinsと○○連携してこう使ってますが多かった

&lt;ul&gt;
&lt;li&gt;Jenkinsを使うのは普通な世界になってる気がする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ちょこっとだけ設定を変えたJobが乱立するのはどこも同じっぽい

&lt;ul&gt;
&lt;li&gt;Workflow Pluginでそのあたりを吸収できそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;会場設備が凄く良い

&lt;ul&gt;
&lt;li&gt;ネット快適、教室は電源とLAN完備&lt;/li&gt;
&lt;li&gt;法政大学凄すぎる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tシャツがフリー配布されてた

&lt;ul&gt;
&lt;li&gt;太っ腹&lt;/li&gt;
&lt;li&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;全てご自由にお持ちくださいらしい。 &lt;a href=&#34;https://twitter.com/hashtag/juc2015?src=hash&#34;&gt;#juc2015&lt;/a&gt; &lt;a href=&#34;http://t.co/0C4ZcEfHXg&#34;&gt;http://t.co/0C4ZcEfHXg&lt;/a&gt;&lt;/p&gt;&amp;mdash; おおた (@ota42y) &lt;a href=&#34;https://twitter.com/ota42y/status/554113306349539328&#34;&gt;2015, 1月 11&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Jenkinsのbuild flow pluginを使うとjobの設定管理が少し楽になる</title>
      <link>http://ota42y.com/blog/2014/11/27/jenkins-build-flow-plugin/</link>
      <pubDate>Thu, 27 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/11/27/jenkins-build-flow-plugin/</guid>
      <description>

&lt;h1 id=&#34;まとめ:e43210b67d1ef6ec3aec4d3b4c38c191&#34;&gt;まとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Jenkinsのjobの設定管理はリポジトリのバージョンと揃えないと行けないため面倒&lt;/li&gt;
&lt;li&gt;全てをスクリプトで実行するのが理想だが、本体の機能を使いたい場合は対応できない&lt;/li&gt;
&lt;li&gt;build flow pluginがファイルを読み込んで実行できるようになった&lt;/li&gt;
&lt;li&gt;これにより、Jenkinsのjobを呼び出すスクリプトをリポジトリ内に入れてバージョン管理出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;jenkinsのjob設定問題:e43210b67d1ef6ec3aec4d3b4c38c191&#34;&gt;Jenkinsのjob設定問題&lt;/h1&gt;

&lt;p&gt;Jenkinsの大きな問題の一つは、Jenkinsのjob設定をどう管理するかだと思います。&lt;/p&gt;

&lt;p&gt;例えばビルド手順を変更する場合、プラグイン設定に後方互換性がないような変更を行うと、&lt;br /&gt;
前のバージョンをビルドしたときにエラーになります。&lt;/p&gt;

&lt;p&gt;このような場合、通常は最新の変更を取り込む事で解決しますが、&lt;br /&gt;
コードフリーズ中のリリースブランチのように、最新の変更を取り込めない場合はこの方法で解決できません。&lt;/p&gt;

&lt;p&gt;このような場合、二通りの解決方法が存在します。&lt;/p&gt;

&lt;h2 id=&#34;全部スクリプトで処理する方法:e43210b67d1ef6ec3aec4d3b4c38c191&#34;&gt;全部スクリプトで処理する方法&lt;/h2&gt;

&lt;p&gt;一つ目が全部スクリプトでやってしまう方法です。&lt;br /&gt;
Jenkinsのjobからは単一のスクリプトだけを実行し、その中で全てを行います。&lt;/p&gt;

&lt;p&gt;この方法はJenkinsを単なるcronとしてしか使わないため、&lt;br /&gt;
全部自分でやる必要がありますが自由度がとても高いのが特徴です。&lt;/p&gt;

&lt;p&gt;ですがこの方法では、プラグインや下流jobとの連携、特定の処理だけ別ノードで実行するなど、&lt;br /&gt;
Jenkinsの機能が使えなくなります。&lt;/p&gt;

&lt;h2 id=&#34;新しいjobを作っていく方法:e43210b67d1ef6ec3aec4d3b4c38c191&#34;&gt;新しいJobを作っていく方法&lt;/h2&gt;

&lt;p&gt;これに対し、jobの変更管理を諦め、どんどん新しいjobを作ってく方法があります。&lt;br /&gt;
Jenkinsはjobのコピーが容易なため、後方互換性のない変更を加える段階で新しいjobに切り替え、&lt;br /&gt;
以降はそちらでビルドし、過去のバージョン用のビルドが必要なときには残してある前のjobを実行します。&lt;/p&gt;

&lt;p&gt;この方法の場合、Jenkinsの機能を利用しつつ、複数のビルド設定を同時に扱うことが出来ますが、&lt;br /&gt;
どのバージョンでどのjobを動かせばいいかを保存しておけないため、jobが増えていくと問題になります。&lt;/p&gt;

&lt;p&gt;これに対し、build flow pluginを使う事で、どのjobでビルドするかといった情報を、&lt;br /&gt;
リポジトリ内に入れてバージョン管理することが出来ます。&lt;/p&gt;

&lt;h1 id=&#34;build-flow-pluginでjobの関係をリポジトリに入れる:e43210b67d1ef6ec3aec4d3b4c38c191&#34;&gt;build flow pluginでjobの関係をリポジトリに入れる&lt;/h1&gt;

&lt;p&gt;Jenkinsのbuild flow pluginでは、複数のjobをスクリプトから実行することが出来ます。&lt;br /&gt;
&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Build+Flow+Plugin&#34;&gt;Build Flow Plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;具体的には以下のように書くことで、job1が成功したらjob2を実行するといったことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 失敗から成功に変わったか判定
def isFixedBuild(result){
  prev = build.previousBuild
  return prev.result != SUCCESS &amp;amp;&amp;amp; result == SUCCESS
}

// job1を実行
b = build(&amp;quot;job1&amp;quot;)
// job1のログを出力する
out.println b.getLog()

if(b.result == SUCCESS){
  // job1が成功していたらjob2を実行
  b = build(&amp;quot;job2&amp;quot;)

  if (isFixedBuild(b.result)){
    out.println &amp;quot;fixed&amp;quot;
  }else{
    out.println &amp;quot;success&amp;quot;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このbuild flow pluginですが、最近の変更でリポジトリ内のファイルを実行することができるようになりました。&lt;br /&gt;
そのため、メインのjobがリポジトリ内のスクリプトを読み込んで、ビルド用のjobを呼び出すように構築することで、&lt;br /&gt;
二つ目の新しいjobを作っていく方法の問題点だった、リポジトリのバージョンとjobの対応付けが解決します。&lt;/p&gt;

&lt;p&gt;残念ながら、job自体の設定は管理出来ないため、設定を変更したい場合はjobを増やしていく必要がありますが、&lt;br /&gt;
呼び出しはスクリプトから行うため、ビルドの実行自体はスクリプトを呼ぶだけで済みます。&lt;/p&gt;

&lt;p&gt;これは一つ目の全てをスクリプトで行う方法と同じく、リポジトリ内のgroovyファイルを実行する方法になりますが、&lt;br /&gt;
Jenkinsのjobをスクリプト内から呼び出せるため、プラグインといったJenkinsの機能を利用できる利点があります。&lt;/p&gt;

&lt;p&gt;ただし、別のjobに別れてしまうため、&lt;br /&gt;
実行時に設定したパラメーターなどは、呼び出すjob側に一つ一つ明示的に渡す必要があったり、&lt;br /&gt;
ファイルの受け渡しを成果物とCopy Artifact Pluginを利用して行う必要があるなど、&lt;br /&gt;
job間のデータの受け渡しが面倒になるという問題が生じますので注意が必要です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jenkinsで複雑な処理をするときのjob構成について</title>
      <link>http://ota42y.com/blog/2014/07/21/jenkins-architecture/</link>
      <pubDate>Mon, 21 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/07/21/jenkins-architecture/</guid>
      <description>

&lt;p&gt;変数やビルド後の通知設定等が違うために、&lt;br /&gt;
ほぼ同じ内容のjobを15個ぐらい使っていたら、&lt;br /&gt;
だんだんと運用が死んできたのでメモ。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Jenkinsはプラグインの挙動を変えるのが難しいため、&lt;br /&gt;
ほぼ同じだけれど若干違う手順を行う必要がある場合、&lt;br /&gt;
似たようなjobが大量に並び、&lt;br /&gt;
手順の変更時などに全てのjobを変えきるのが辛くなります。&lt;/p&gt;

&lt;p&gt;そこで、可能な限りビルド手順はスクリプトにするのと、&lt;br /&gt;
jobを種類別に細かく分け、&lt;br /&gt;
最上位のjobにはどの下流jobを実行するかだけを管理させることで、&lt;br /&gt;
複雑なjobでも変更に強くすることができるようになります。&lt;/p&gt;

&lt;h1 id=&#34;前提条件:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;前提条件&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;設定が全部で7種類ぐらいある&lt;/li&gt;
&lt;li&gt;1ビルドはCPUをフルパワーで使って30分程度&lt;/li&gt;
&lt;li&gt;一部の設定は定期実行やマージ毎でもビルドしたい&lt;/li&gt;
&lt;li&gt;設定ごとに用途や使う頻度が違う為、定期実行タイミングは個別に設定したい&lt;/li&gt;
&lt;li&gt;ビルド後のデプロイ先や通知先、通知条件がいくつかある&lt;/li&gt;
&lt;li&gt;ビルド手順はバージョン/デプロイ先によって変化する&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;問題点:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;問題点&lt;/h1&gt;

&lt;p&gt;大きな問題として、&lt;br /&gt;
Jenkins pulginで提供されている機能を切り替えるのが難しいという問題があります。&lt;/p&gt;

&lt;p&gt;たとえば、Jenkinsの拡張メールプラグインでは、&lt;br /&gt;
そのjobの結果によって通知先や通知内容等を変更することができます。&lt;br /&gt;
ですが、その定義自体を切り替えることが難しく、&lt;br /&gt;
この場合は成功時にメールしないけど、&lt;br /&gt;
この場合は成功時にメールするといった切り替えができませんでした。&lt;/p&gt;

&lt;p&gt;また、定期的に変更チェックするブランチや、チェックする間隔が設定毎に異なりますが、&lt;br /&gt;
JenkinsのGit プラグインではそのあたりをうまく設定することが難しいようです。&lt;/p&gt;

&lt;p&gt;他にもdeploy先によって使うプラグインが微妙に違うなどの問題があり、&lt;br /&gt;
ほぼ同じだけれど若干違うjobを15個並べるといった運用をしていました。&lt;/p&gt;

&lt;p&gt;こんな感じに、ほぼ同じだけれど若干違うビルドが並びます。&lt;br /&gt;
&lt;img src=&#34;http://ota42y.com/images/blog/2014/2014-07-21-jenkins-1.png&#34; alt=&#34;こんな感じ&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;結果として、ビルド手順の変更時などに全てのビルドを変更しきることが難しかったり、&lt;br /&gt;
古い手順のバージョンのマイクロアップデートと、&lt;br /&gt;
新しい手順のメジャーアップデートが重なったときに、&lt;br /&gt;
ビルド前にJenkinsの設定を必ず変更する必要がある等、&lt;br /&gt;
運用がかなり辛くなってきました。&lt;/p&gt;

&lt;p&gt;これに対する対策を考えましたが、あまり良いのが無い感じですが、&lt;br /&gt;
とりあえずまとまったのでメモをしておきます。&lt;/p&gt;

&lt;h1 id=&#34;解決案:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;解決案&lt;/h1&gt;

&lt;h2 id=&#34;1-ビルド手順や通知を全てをシェルスクリプトにし-jenkinsはシェルを叩くだけにする:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;1.ビルド手順や通知を全てをシェルスクリプトにし、Jenkinsはシェルを叩くだけにする&lt;/h2&gt;

&lt;p&gt;Jenkinsのプラグインをほぼ使用せず、全てスクリプトで解決する手法です。&lt;br /&gt;
 ビルド手順や通知がSCMに保存されるため、ビルド手順とバージョンが完全に紐付き、&lt;br /&gt;
 常に正しい手順で実行できるという利点があります。&lt;/p&gt;

&lt;p&gt;だだし、Jenkinsプラグインの恩恵を得られないため、&lt;br /&gt;
 今プラグインでやっている処理を全て置き換える必要があります。&lt;br /&gt;
 また、新たな手順の追加が大変と言った問題もあります。&lt;/p&gt;

&lt;h2 id=&#34;2-ワークスペース共有を使ってうまくやる:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;2.ワークスペース共有を使ってうまくやる&lt;/h2&gt;

&lt;p&gt;チェックアウトとビルドジョブを切り離し、&lt;br /&gt;
  SCMのポーリング&amp;amp;チェックアウトだけを行うjobから、&lt;br /&gt;
  ビルドジョブを下流ビルドとして呼び出す方式です。&lt;/p&gt;

&lt;p&gt;こんな感じですね。&lt;br /&gt;
  &lt;img src=&#34;http://ota42y.com/images/blog/2014/2014-07-21-jenkins-2.png&#34; alt=&#34;ワークスペース共有&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ワークスペース共有を使い、&lt;br /&gt;
  下流ビルドは上流のワークスペース上でビルド作業を行うようにすることで、&lt;br /&gt;
  ビルドjobの数を大幅に減らすことができます。&lt;/p&gt;

&lt;p&gt;だだし、下流が実行中は上流ビルドが動かない事を保証しなければなりません。&lt;br /&gt;
  (ビルド途中に次のキューによってワークスペースが書き換えられる可能性がある)
  Parameterize pluginで下流が終わるまで終了を待つ事ができますが、&lt;br /&gt;
  複数のビルドが同時に走った場合にデッドロックに陥る可能性があります。
  - A-Cとビルドするjobと、B-Cとビルドするjobがあり、jenkinsの同時実行が2の場合、&lt;br /&gt;
   2つのビルドを同時に実行するとCが2つともキューに積まれて進まない場合がある&lt;/p&gt;

&lt;h2 id=&#34;3-jobを疎結合にして成果物を使ってうまくやる:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;3.jobを疎結合にして成果物を使ってうまくやる&lt;/h2&gt;

&lt;p&gt;2のデッドロックを回避するために、疎結合にした版になります。&lt;br /&gt;
  この方式ではワークスペースを共有せず、&lt;br /&gt;
  コミットのSHA1を渡してビルドジョブ側でcheckout, buildします。&lt;br /&gt;
  また、Remote APIを利用することで、シェルスクリプトから次に実行するビルドの指定もできます。&lt;/p&gt;

&lt;p&gt;2の利点をそのまま受け継ぎ、ワークスペース共有しないのでブロックしなくなります。&lt;br /&gt;
  ビルド結果などは成果物の保存と、Copy Artifact Pluginを利用して受け渡します。&lt;br /&gt;
  そのため、後続のjobの実行前にワークスペースが変更されても問題なく進められます。&lt;/p&gt;

&lt;p&gt;ただし、ポーリング用とビルド用とで二重にSCMをチェックアウトする必要があるのと、&lt;br /&gt;
  ビルドログが完全に細切れになるため追いにくく、&lt;br /&gt;
  またいつ何が正常に終了したかを把握しにくいという問題があります。&lt;/p&gt;

&lt;h2 id=&#34;4-master-slaveにして-masterからslaveのjobを呼び出すようにする:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;4.master-slaveにして、masterからslaveのjobを呼び出すようにする&lt;/h2&gt;

&lt;p&gt;3のやりかたを踏まえつつ、個別のjobでは無く下流のjobとして運用する方法です。&lt;br /&gt;
 そのために、2で問題となっていたキューが埋まる問題への解決策を入れました。&lt;/p&gt;

&lt;p&gt;具体的には、ポーリング等を実行する最上流のjobをJenkinsのmasterでのみ実行し、&lt;br /&gt;
 ビルドや通知を下流jobとしてslaveでビルドするようにします。&lt;br /&gt;
 このように設定することで、masterが全て上流jobで埋まったとしても、&lt;br /&gt;
 slaveで下流jobが実行されるため、デッドロックが発生しません。&lt;/p&gt;

&lt;p&gt;これにより、上流jobはビルドが完全に終了するまで終了を待つことができ、&lt;br /&gt;
 終了タイミングを把握しやすくなります。&lt;/p&gt;

&lt;p&gt;だたし、問題点としてmaster-slave構成にするため、稼働するマシンが増える、&lt;br /&gt;
 jobをmasterとslaveどっちでやるかを考えないといけない、&lt;br /&gt;
 下流jobとして紐付けはされるが、ログはまだ細切れになっているといった問題があります。&lt;/p&gt;

&lt;h1 id=&#34;おわりに:1454c4e5d7cb83f9989cba8b03537b99&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;とりあえず今のところは、4番が一番いい方法ではないかと考えています。&lt;br /&gt;
そのためしばらくこれで運用し、また問題が起きた場合、&lt;br /&gt;
次なる手を考えるとして、今のところは4番で行く予定です。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>