<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins on おおたの物置</title>
    <link>http://ota42y.com/tags/jenkins/</link>
    <description>Recent content in Jenkins on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 28 Feb 2016 19:37:37 +0900</lastBuildDate>
    
	<atom:link href="http://ota42y.com/tags/jenkins/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Jenkinsのノード選択をNode and Label parameter pluginでやる</title>
      <link>http://ota42y.com/blog/2016/02/28/jenkins_node_select/</link>
      <pubDate>Sun, 28 Feb 2016 19:37:37 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2016/02/28/jenkins_node_select/</guid>
      <description> 概要 Jenkinsのノード制御はあまりカスタマイズが効きません。そのため、ノードを細かく制御したい場合はジョブを分ける必要があり、ジョブ数が増えて管理コストが上がります。このプラグインはパラメーターでノードを選択できるので、一つのジョブでノードごとにジョブを動かせるようになります。
Jenkinsのノード選択は柔軟性に欠ける Jenkinsのノード選択がパラメータでできるプラグインです。 Jenkinsでは基本機能として、実行するノードを制限して特定ノードでだけジョブを実行できます。 ですが、この設定項目は柔軟性に欠け、パラメータでノードを切り替えたり、該当するノード全てでビルドするといったことができません。 そのため、例えばgoでWindowsとMac両方でテストを実行したい場合、windows用とmac用というノードごとの個別のジョブを作る必要があります。 しかし、それを続けるとJenkinsのジョブの数が際限なく増えていき、ジョブのメンテが大変になるという問題が出ます。
Node and Label parameter plugin https://wiki.jenkins-ci.org/display/JENKINS/NodeLabel+Parameter+Plugin
Node and Label parameter pluginは、以上の問題点を解決できるプラグインです。このプラグインを入れると、ビルド時のパラメータにNodeとLabelを追加することができるようになります。

Nodeの場合は文字通り任意のノード名でビルドノードを選択できます。 また、Labelの場合はノードにつけたLabelでビルドするノードを選択できます。 そのため、ノードにwindowsやmac等の適切なラベルをつけることで、任意のノードでビルドすることができるようになります。 また、全てのノードに共通のラベルを一つ定義しておくことで、どれでもいいからとりあえずビルドするといったこともできます。
該当するノード全てでビルドする このプラグインは、特に設定がない場合は該当するノードのどれか一つでjobが実行されますが、以下のオプションをつけることで該当するノード全てで実行されるようになります。 そのため、複数環境でテストしたい場合も１回ビルドを実行するだけで後は自動で全てのノードでビルドが実行されるようになります。 なお、全ノードで実行される一つのビルドではなく、ノードごとに個別のビルドが実行されるようです。

Pipeline Pluginとの違い Pipeline Pluginでは、Jenkinsのジョブを丸ごとgroovyで書けるため、このプラグインよりもさらに柔軟に選択できます。 ただ、こちらは本当にジョブの内容を全てgroovyで書く必要があり、既存のJenkinsの知見を活用できなかったり、他のプラグインとの相性はあまり良くないです。 Node and Label parameter pluginはパラメータのみ変更されるため、標準的なジョブ構成であればとても簡単に導入できます。 そのため、どうしても複雑な制御が必要な時にのみPipeline Pluginを使うべきだと思います。
まとめ  通常の機能だとノードをあまり制御するのは難しい プラグインで任意のノードをパラメーターで選択できる  選択方法はノード名とラベル ラベルは複数に同じラベルをつけたりといろいろ便利なのでオススメ  ノード選択部分をさらに柔軟にしたいならPipeline Plugin  より複雑な事ができるが、導入の敷居も高い Jenkins Workflow Pluginで複数slaveを扱うのが楽になる   </description>
    </item>
    
    <item>
      <title>JenkinsをHTTP経由で叩く</title>
      <link>http://ota42y.com/blog/2015/02/27/jenkins-remote-api/</link>
      <pubDate>Fri, 27 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/02/27/jenkins-remote-api/</guid>
      <description>まとめ  JenkinsはWebベースのUI  操作の敷居が低い 使い込むと使いづらくなる 反応速度 複数のビルド実行  Remote access API  HTTP経由でJobを実行できる ページ表示を待たなくていいため高速 プログラムから実行可能 ただし、Jenkinsの仕様上、実行したビルドのビルド番号は解らない
   JenkinsのJob実行は大変 JenkinsはWebブラウザを使ってGUIで操作するため、
操作の敷居が低く、簡単に扱えるようになっています。
ですが、ブラウザやJenkins本体の状態によってはとても遅くなってしまい、
ページを切り替えるのに3，4秒待つといった状態まで遅くなると、
ビルドをするのがとても辛くなります。
また、パラメータの組み合わせの分だけビルドしようとすると、
さらに辛くなってしまいます。
このような場合に、Jenkinsに用意されているRemote access APIを使うことで、
Jenkinsをプログラムから制御でき、反応の遅さに悩まされたり、
パラメータの数だけクリックをする必要性から逃れられます。
Remote access API 詳しくはこちら
https://wiki.jenkins-ci.org/display/JENKINS/Remote+access+API
https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Build
要するに、パラメータが無い場合は
http://HOST/job/JOB_NAME/build に、ある場合は
http://HOST/job/JOB_NAME/buildWithParameters にPOSTで投げるとビルドできます。
パラメータの投げ方はフォームデータとしてでもいいですし、
http://HOST/job/JOB_NAME/buildWithParameters?PARAMETER=Value のように、URLに直接入れても大丈夫のようです。
サンプルスクリプト 3*3=9種類のビルドを一気に実行するスクリプトです
require &#39;open-uri&#39; require &#39;net/http&#39; platforms = [&amp;quot;ios&amp;quot;, &amp;quot;android&amp;quot;, &amp;quot;windows&amp;quot;] settings = [&amp;quot;debug&amp;quot;,&amp;quot;release&amp;quot;, &amp;quot;store&amp;quot;] platforms.product(settings).each do |platform, setting| params = {:PLATFORM =&amp;gt; platform, :SETTING =&amp;gt; setting} p params url = URI.</description>
    </item>
    
    <item>
      <title>Jenkins Workflow Pluginでリポジトリ内のスクリプトを読み込む時の注意点</title>
      <link>http://ota42y.com/blog/2015/02/11/jenkins-workflow/</link>
      <pubDate>Wed, 11 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/02/11/jenkins-workflow/</guid>
      <description>まとめ  ブランチをパラメーターにするとスクリプトを読めない  中身ではなく変数名のブランチを探しに行く 多分バグ  ファイルから読み込むるスクリプトを書けば解決  公式のflow.groovyを参考に 変数を使おうとすると面倒 java.io.Serializableを実装する必要あり   gitリポジトリ内のスクリプトを指定できない (以下に用意されているdocker上のJenkinsで確認しました)
https://github.com/jenkinsci/workflow-plugin/blob/master/demo/README.md
Workflow Pluginでは、リポジトリ内のgroovyスクリプトを読み込んで実行する機能があります。
この機能を使うことで、リポジトリの内容とそれに対応するビルド手順を同時にバージョン管理出来るため、
ビルド手順の変更がとてもやりやすくなります。
ですが残念ながら、パラメータで指定したブランチをチェックアウトして読み込むと、以下のエラーになります。
&amp;gt; git config remote.origin.url /var/lib/jenkins/workflow-plugin-pipeline-demo # timeout=10 Fetching upstream changes from /var/lib/jenkins/workflow-plugin-pipeline-demo &amp;gt; git --version # timeout=10 &amp;gt; git -c core.askpass=true fetch --tags --progress /var/lib/jenkins/workflow-plugin-pipeline-demo +refs/heads/*:refs/remotes/origin/* &amp;gt; git rev-parse origin/$BRANCH_NAME^{commit} # timeout=10 &amp;gt; git rev-parse $BRANCH_NAME^{commit} # timeout=10  パラメータの内容ではなく、パラメータの名前そのものを探しに行っており、おそらくバグと思われます。
通常のJobでGit Pluginを使うと問題なくパラメータ指定が出来るため、Workflowのバグと思われます。
このバグは、Jenkinsでは事前に設定した特定ブランチしかビルドしない場合は問題ありません。
ですが、様々なブランチで実行する可能性がある場合、JenkinsのJob設定にスクリプトを書かなければならず、
ビルド手順自体の管理が大変になります。
このような場合、スクリプトをロードして実行するスクリプトをJobに設定することで、
指定したブランチからスクリプトを読み込んで実行できます。</description>
    </item>
    
    <item>
      <title>Jenkins Workflow Pluginで複数slaveを扱うのが楽になる</title>
      <link>http://ota42y.com/blog/2015/02/10/workflow-plugin/</link>
      <pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/02/10/workflow-plugin/</guid>
      <description>まとめ  Jenkinsはjob単位でしかノードに割り振れない  複数ノードで分散ビルドするには設定を駆使する必要がある 結果としてjobの数が増えて管理コストが増大する  Workflow Pluginで大幅に改善する  スクリプトからノードを指定してコマンドを実行できる 複数のjobを組み合わせていたのが一つのスクリプトですむ スクリプトをVCSに入れればビルド設定のバージョン管理も可能   複数ノードをコントロールするのは難しい Jenkinsを一つのノードで運用している場合はそれほど問題になりませんが、
複数のノードで、jobの一部の部分だけを別のノードで実行するなど、
ある程度複雑な分散をやろうとすると、Jenkins本体の機能では不足してきます。
このような問題に対して、これまではBuild Flow Pluginを使う事で解決が可能でしたが、
Workflow Pluginを使う事で、さらに簡単に解決することが出来ます。
Build Flow Pluginの問題点 Build Flow Pluginは基本的に複数の下流ビルドを管理するために作られているため、
処理を分けようとするとjobの数が増加していきます。
例えばネイティブアプリのビルドのようなCPUパワーを使う処理と、パワーを使わないアップロード処理がある場合、
一つのノードで全てやるよりも、非力なサーバを確保してアップロード処理をそちらで実行した方が、
ビルド用のノードはビルドに専念でき、無駄なくjobを実行できます。
(また、masterとビルドを同じノードでやるとJenkins本体の処理が遅くなるため、分割する利点は他にもあります)
(上段のup#4はup#3の間違いです…)
ビルドが数十分、数時間かかるような巨大な処理の場合、
処理を分散することで稼げる時間はかなりのものになります。
従来では分割する作業を別のjobにし、かつBuild Flow Plugin用のjobを作る必要があります。
さらに、ファイルの受け渡しもできないため、成果物として保存して、
次のjobは前のjobの特定のビルド番号の成果物を取り出す…といった風になります。
jobの数が増えると管理も大変ですし、使う方もどれを使えば良いのか解らなくなります。
ここで、Workflow Pluginを使うことで大きく改善することが出来ます。
Workflow Pluginを使ったビルド Workflow Pluginでは、slaveを選択してコマンドを実行、
特定のファイルを別のslaveにコピーして処理を実行ということががスクリプトで書けます。
例えば以下のように書くことで、masterでファイルを生成してslaveで実行、
その後結果をmasterにコピーしてアップロードみたいな事が出来ます。
node(&amp;quot;master&amp;quot;){ sh &amp;quot;rake config&amp;quot; archive &amp;quot;config.yml&amp;quot; } node(&amp;quot;slave&amp;quot;){ unarchive mapping: [&#39;config.yml&#39; : &#39;./&#39;] sh &amp;quot;rake build&amp;quot; archive &amp;quot;result.</description>
    </item>
    
    <item>
      <title>参加記録 Jenkins ユーザ・カンファレンス 2015 東京</title>
      <link>http://ota42y.com/blog/2015/01/11/jenkins-conference/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/11/jenkins-conference/</guid>
      <description>Jenkins ユーザ・カンファレンス 2015 東京に参加しました。
Togetterまとめ
発表まとめ アンケート結果  参加申し込み時のアンケート結果 多くの人のjobの数が1〜数個程度 Jenkins無くても生きていける人が30％ぐらい
 思ったよりもみんなJenkinsを使い込んでいない印象 アンケート結果は後日公開  Jenkinsプロジェクトの現状とワークフロー  DotCiが良さそう  https://github.com/groupon/DotCi Jenkinsを他のCIサービスみたいにする Github限定 設定をYAMLファイルで管理出来たりする  Workflow Pluginすごい  Build Flow Pluginをいっそう強化した版 ビルドが失敗しても途中から再開とかも出来る 乗り換えよう ただ、DSLを覚えたりと学習コストが高くなるので秘伝のタレ化の危険が   JenkinsとSeleniumの活用事例：試験自動化のプロジェクトへの導入  アジャイル開発だとイテレーション毎に試験項目は増えていくが、開発後半になるほど試験に割ける時間は減る  あるあるすぎる 試験自動化で試験項目の消化にかかるコストを下げる  スクリーンショットを撮って画像比較して変更検知  静的な画面なら効果的っぽい アニメーションする場合は撮るタイミングによりそうなので、目で比較かなぁ…  テストケースの保守大変そう  ちょっと変わっただけで使えなくなるし   Jenkinsを使ったコンシューマゲームでのデプロイとテスト  http://www.slideshare.net/swiftnest/jenkins-43394510 圧縮して6GB、11万ファイルのプロジェクト  2プラットフォーム2言語にビルド これで中規模ぐらいと凄い世界が…  FFとかどんだけなんだろう…   フルビルドに14時間かかる  リソースの事前処理に時間がかかる  リソース内での分岐処理が遅いため、全条件分のリソースを作る  データを実機上でビルドする必要がある  携帯機は貧弱なので差分ビルドでも4時間かかったりする プラットフォームで互換性なし PS3はビッグエンディアン VITAはリトルエンディアン  ファイルをパックするのでキャッシュが効かない  ファイルアクセス回数を減らすため必須 全データを実機でパックするため6時間ぐらい   頑張って並列化して5〜9時間ぐらいまで減らす  データの処理を4台で並列化  一台4時間ぐらいに短縮   テスト  テストフレームワークなど無い スモークテスト  特定ミッションに入れるかどうかをテスト 引数で専用のミッションを始められるように  一定時間たったら終了させる 正常終了しなかったらエラー  起動からスタート、終了までがちゃんと動くか リソースに問題ないか エフェクト再生チェック 一定時間内に終わるか データが変換可能か  モンキーテスト  開始からエンディングまでの通しプレイAI 良い感じに攻撃する  適当にボタン連打  適当に移動 何回もゲームオーバーになったら無敵＆攻撃力１００倍 メニュー操作テスト 普通のUIテストっぽい 長時間テスト特有のバグ発見に繋がる リソースの解放漏れ  携帯機はスリープできるので普通は電源を切らない   問題点  作成やメンテナンスにコストがかかる ゆとりがある時期にどれだけ作れるか勝負 チェックに時間かかる 一日じゃ終わらない 手動テストの置き換えにはならない テストのパターンが固定化されるため、外れた部分のバグは検知不可 人の手のかかるテストを減らす効果    おばかXFDコンテスト  人は慣れる生き物  何度も通知してるとそのうち無視するようになる  エラーメールを迷惑フォルダに入れたり パトランプの上に被せたり  XFDによる通知で、慣れに逆らう   LT大会  Jenkinsを使った継続的Webセキュリティテスト  継続的にセキュリティテストを実施するVAddyの話  http://vaddy.</description>
    </item>
    
    <item>
      <title>Jenkinsのbuild flow pluginを使うとjobの設定管理が少し楽になる</title>
      <link>http://ota42y.com/blog/2014/11/27/jenkins-build-flow-plugin/</link>
      <pubDate>Thu, 27 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/11/27/jenkins-build-flow-plugin/</guid>
      <description>まとめ  Jenkinsのjobの設定管理はリポジトリのバージョンと揃えないと行けないため面倒 全てをスクリプトで実行するのが理想だが、本体の機能を使いたい場合は対応できない build flow pluginがファイルを読み込んで実行できるようになった これにより、Jenkinsのjobを呼び出すスクリプトをリポジトリ内に入れてバージョン管理出来る  Jenkinsのjob設定問題 Jenkinsの大きな問題の一つは、Jenkinsのjob設定をどう管理するかだと思います。
例えばビルド手順を変更する場合、プラグイン設定に後方互換性がないような変更を行うと、
前のバージョンをビルドしたときにエラーになります。
このような場合、通常は最新の変更を取り込む事で解決しますが、
コードフリーズ中のリリースブランチのように、最新の変更を取り込めない場合はこの方法で解決できません。
このような場合、二通りの解決方法が存在します。
全部スクリプトで処理する方法 一つ目が全部スクリプトでやってしまう方法です。
Jenkinsのjobからは単一のスクリプトだけを実行し、その中で全てを行います。
この方法はJenkinsを単なるcronとしてしか使わないため、
全部自分でやる必要がありますが自由度がとても高いのが特徴です。
ですがこの方法では、プラグインや下流jobとの連携、特定の処理だけ別ノードで実行するなど、
Jenkinsの機能が使えなくなります。
新しいJobを作っていく方法 これに対し、jobの変更管理を諦め、どんどん新しいjobを作ってく方法があります。
Jenkinsはjobのコピーが容易なため、後方互換性のない変更を加える段階で新しいjobに切り替え、
以降はそちらでビルドし、過去のバージョン用のビルドが必要なときには残してある前のjobを実行します。
この方法の場合、Jenkinsの機能を利用しつつ、複数のビルド設定を同時に扱うことが出来ますが、
どのバージョンでどのjobを動かせばいいかを保存しておけないため、jobが増えていくと問題になります。
これに対し、build flow pluginを使う事で、どのjobでビルドするかといった情報を、
リポジトリ内に入れてバージョン管理することが出来ます。
build flow pluginでjobの関係をリポジトリに入れる Jenkinsのbuild flow pluginでは、複数のjobをスクリプトから実行することが出来ます。
Build Flow Plugin
具体的には以下のように書くことで、job1が成功したらjob2を実行するといったことが出来ます。
// 失敗から成功に変わったか判定 def isFixedBuild(result){ prev = build.previousBuild return prev.result != SUCCESS &amp;amp;&amp;amp; result == SUCCESS } // job1を実行 b = build(&amp;quot;job1&amp;quot;) // job1のログを出力する out.println b.getLog() if(b.result == SUCCESS){ // job1が成功していたらjob2を実行 b = build(&amp;quot;job2&amp;quot;) if (isFixedBuild(b.</description>
    </item>
    
    <item>
      <title>Jenkinsで複雑な処理をするときのjob構成について</title>
      <link>http://ota42y.com/blog/2014/07/21/jenkins-architecture/</link>
      <pubDate>Mon, 21 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/07/21/jenkins-architecture/</guid>
      <description>変数やビルド後の通知設定等が違うために、
ほぼ同じ内容のjobを15個ぐらい使っていたら、
だんだんと運用が死んできたのでメモ。
まとめ Jenkinsはプラグインの挙動を変えるのが難しいため、
ほぼ同じだけれど若干違う手順を行う必要がある場合、
似たようなjobが大量に並び、
手順の変更時などに全てのjobを変えきるのが辛くなります。
そこで、可能な限りビルド手順はスクリプトにするのと、
jobを種類別に細かく分け、
最上位のjobにはどの下流jobを実行するかだけを管理させることで、
複雑なjobでも変更に強くすることができるようになります。
前提条件  設定が全部で7種類ぐらいある 1ビルドはCPUをフルパワーで使って30分程度 一部の設定は定期実行やマージ毎でもビルドしたい 設定ごとに用途や使う頻度が違う為、定期実行タイミングは個別に設定したい ビルド後のデプロイ先や通知先、通知条件がいくつかある ビルド手順はバージョン/デプロイ先によって変化する  問題点 大きな問題として、
Jenkins pulginで提供されている機能を切り替えるのが難しいという問題があります。
たとえば、Jenkinsの拡張メールプラグインでは、
そのjobの結果によって通知先や通知内容等を変更することができます。
ですが、その定義自体を切り替えることが難しく、
この場合は成功時にメールしないけど、
この場合は成功時にメールするといった切り替えができませんでした。
また、定期的に変更チェックするブランチや、チェックする間隔が設定毎に異なりますが、
JenkinsのGit プラグインではそのあたりをうまく設定することが難しいようです。
他にもdeploy先によって使うプラグインが微妙に違うなどの問題があり、
ほぼ同じだけれど若干違うjobを15個並べるといった運用をしていました。
こんな感じに、ほぼ同じだけれど若干違うビルドが並びます。
結果として、ビルド手順の変更時などに全てのビルドを変更しきることが難しかったり、
古い手順のバージョンのマイクロアップデートと、
新しい手順のメジャーアップデートが重なったときに、
ビルド前にJenkinsの設定を必ず変更する必要がある等、
運用がかなり辛くなってきました。
これに対する対策を考えましたが、あまり良いのが無い感じですが、
とりあえずまとまったのでメモをしておきます。
解決案 1.ビルド手順や通知を全てをシェルスクリプトにし、Jenkinsはシェルを叩くだけにする Jenkinsのプラグインをほぼ使用せず、全てスクリプトで解決する手法です。
ビルド手順や通知がSCMに保存されるため、ビルド手順とバージョンが完全に紐付き、
常に正しい手順で実行できるという利点があります。
だだし、Jenkinsプラグインの恩恵を得られないため、
今プラグインでやっている処理を全て置き換える必要があります。
また、新たな手順の追加が大変と言った問題もあります。
2.ワークスペース共有を使ってうまくやる チェックアウトとビルドジョブを切り離し、
SCMのポーリング&amp;amp;チェックアウトだけを行うjobから、
ビルドジョブを下流ビルドとして呼び出す方式です。
こんな感じですね。
ワークスペース共有を使い、
下流ビルドは上流のワークスペース上でビルド作業を行うようにすることで、
ビルドjobの数を大幅に減らすことができます。
だだし、下流が実行中は上流ビルドが動かない事を保証しなければなりません。
(ビルド途中に次のキューによってワークスペースが書き換えられる可能性がある) Parameterize pluginで下流が終わるまで終了を待つ事ができますが、
複数のビルドが同時に走った場合にデッドロックに陥る可能性があります。 - A-Cとビルドするjobと、B-Cとビルドするjobがあり、jenkinsの同時実行が2の場合、
2つのビルドを同時に実行するとCが2つともキューに積まれて進まない場合がある
3.jobを疎結合にして成果物を使ってうまくやる 2のデッドロックを回避するために、疎結合にした版になります。</description>
    </item>
    
  </channel>
</rss>