<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pages on おおたの物置</title>
    <link>http://ota42y.com/pages/</link>
    <description>Recent content in Pages on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 21 Jul 2015 17:56:49 +0900</lastBuildDate>
    <atom:link href="http://ota42y.com/pages/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2015年29週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-29/</link>
      <pubDate>Tue, 21 Jul 2015 17:56:49 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-29/</guid>
      <description>

&lt;p&gt;#CPUの特権レベルについて調べた
&lt;a href=&#34;https://ja.wikipedia.org/wiki/CPU%E3%83%A2%E3%83%BC%E3%83%89&#34;&gt;CPUモード&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;リングプロテクション&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CPUには複数のモードが存在し、特定の機能やメモリ領域にアクセスできるかどうかがこのモードで制御されるらしいです。&lt;/p&gt;

&lt;p&gt;通常、ユーザのプログラムはレベル３、カーネルがレベル０で動いており、&lt;br /&gt;
ユーザのプログラムはレベル０で動いています。&lt;br /&gt;
そのため、 レベル０用のリソースを使うためにはカーネルに処理をお願いする必要があるそうです。&lt;/p&gt;

&lt;h1 id=&#34;goのビルドツールについて調べる:c2d0a3130aad94273f8f684d791e0140&#34;&gt;goのビルドツールについて調べる&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;go build&lt;/code&gt;を実行することで、コンパイルとリンクをまとめて行うことが出来ます。&lt;br /&gt;
ですが、goではそれを別々に実行することも出来ます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go tool 8g&lt;/code&gt;もしくは&lt;code&gt;go tool 6g&lt;/code&gt;を使うことで、goのソースコードからオブジェクトファイルを作成できます。&lt;br /&gt;
(どちらかは使用しているマシンのアーキテクチャによります)&lt;/p&gt;

&lt;p&gt;生成されるオブジェクトファイルは.8もしくは.6の拡張子になります。&lt;br /&gt;
このファイルを&lt;code&gt;go tool 8l&lt;/code&gt;もしくは&lt;code&gt;go tool 6l&lt;/code&gt;を使ってリンクすることで、実行ファイルを作成できます。&lt;br /&gt;
実行ファイルはファイル名を指定しない場合、8.outもしくは6.outになります。&lt;/p&gt;

&lt;h1 id=&#34;レーベンシュタイン距離計算を実装した:c2d0a3130aad94273f8f684d791e0140&#34;&gt;レーベンシュタイン距離計算を実装した&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/ota42y/29dc71841f4388957020&#34;&gt;https://gist.github.com/ota42y/29dc71841f4388957020&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;二つの文字列のうち、片方をどれくらい編集したらもう片方の文字列に出来るかを求めるやつです。&lt;br /&gt;
アルゴリズム的には凄い簡単ですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年28週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-28/</link>
      <pubDate>Mon, 13 Jul 2015 23:25:27 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-28/</guid>
      <description>

&lt;h1 id=&#34;シェル環境を改善中:581fc548323f605be65cf3be104399ee&#34;&gt;シェル環境を改善中&lt;/h1&gt;

&lt;p&gt;tmux plugin managerを導入しました。&lt;br /&gt;
&lt;a href=&#34;https://github.com/tmux-plugins/tpm&#34;&gt;https://github.com/tmux-plugins/tpm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;tmuxのconfファイルでやる設定をある程度共通化し、
プラグインのインストールだけで使えるようにするものです。&lt;br /&gt;
公式でいくつか便利なものが提供されているので入れてみました。&lt;br /&gt;
プラグインは自分で作れるので、swap-paneもこれで管理したいな…と思います。&lt;/p&gt;

&lt;h1 id=&#34;pecoの導入:581fc548323f605be65cf3be104399ee&#34;&gt;pecoの導入&lt;/h1&gt;

&lt;p&gt;入力からインクリメンタルに行を検索できるツールです。&lt;br /&gt;
goなのでバイナリ単体で簡単に動き、インストールが簡単なのが特徴です。&lt;br /&gt;
&lt;a href=&#34;https://github.com/peco/peco&#34;&gt;https://github.com/peco/peco&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ota42y/dotfiles/commit/62ea2fa76cfa0fab8ee8076e0eb59f3b1421b42e&#34;&gt;前にいたディレクトリをたどる設定&lt;/a&gt;や、
&lt;a href=&#34;https://github.com/ota42y/dotfiles/commit/2d16f36f14520862eb5292b05c278016d180bdf3&#34;&gt;git statusから指定したファイルをinsertする設定&lt;/a&gt;をしました。&lt;/p&gt;

&lt;h1 id=&#34;markdown-modeが便利:581fc548323f605be65cf3be104399ee&#34;&gt;markdown-modeが便利&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://jblevins.org/projects/markdown-mode/&#34;&gt;http://jblevins.org/projects/markdown-mode/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;emacs上でmarkdownのハイライトやスニペット入力が出来る便利モードです。&lt;br /&gt;
個人的には見出しをorg-modeのように折りたたみが出来るので、&lt;br /&gt;
アウトラインエディタとしてものすごく便利です。&lt;/p&gt;

&lt;h1 id=&#34;mecab-ipadicをいじっていた:581fc548323f605be65cf3be104399ee&#34;&gt;mecab-ipadicをいじっていた&lt;/h1&gt;

&lt;p&gt;形態素解析をいじってみたくて、igoとmecab-ipadicについて調べていました。&lt;/p&gt;

&lt;h2 id=&#34;igoとは:581fc548323f605be65cf3be104399ee&#34;&gt;igoとは&lt;/h2&gt;

&lt;p&gt;igoとはjava製の形態素解析です。
&lt;a href=&#34;http://igo.osdn.jp/&#34;&gt;http://igo.osdn.jp/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;javaとantがあれば直ぐに使えるため、インストールがとても楽です。&lt;br /&gt;
なお、辞書は同梱されていないため、mecabの辞書を取ってくる必要があります。&lt;br /&gt;
&lt;a href=&#34;http://taku910.github.io/mecab/&#34;&gt;http://taku910.github.io/mecab/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;辞書が組み込みではないので普通に使う分にはちょっと面倒ですが、
今回のように辞書をいじって動きを観察する用途にとても便利でした。&lt;/p&gt;

&lt;h2 id=&#34;ipadicを変更してみる:581fc548323f605be65cf3be104399ee&#34;&gt;ipadicを変更してみる&lt;/h2&gt;

&lt;p&gt;igoの動かし方はサイトの通りなので省略します。&lt;/p&gt;

&lt;p&gt;ipadicから解析用のバイナリ辞書を生成する手順がありますが、&lt;br /&gt;
このときipadicのフォルダに辞書ファイルを追加する事で、新たな辞書を追加する事が出来ます。&lt;br /&gt;
また、既存のファイルを削除することで単語の登録をさせないことが出来るため、&lt;br /&gt;
自分が作った辞書だけにすることで、正しく使えるかどうかを調べることが出来ます。&lt;/p&gt;

&lt;p&gt;なお、バイナリ辞書作成時はフォルダの中のcsvを全て読み込むらしく、&lt;br /&gt;
追加時に必要な設定などは無いようです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年27週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-27/</link>
      <pubDate>Mon, 06 Jul 2015 22:42:53 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-27/</guid>
      <description>

&lt;h1 id=&#34;tmux環境を整えた:26038bc9325a7e1e74b9ae9d9fc662f9&#34;&gt;tmux環境を整えた&lt;/h1&gt;

&lt;p&gt;画像のように、tmux内でemacsを開きつつ、zshを表示するようにしました。&lt;br /&gt;
ただペインを分けているだけでなく、ペインの中身はウィンドウなので、&lt;br /&gt;
ウィンドウを作って入れ換えたり、左右の中身を入れ換えたり出来ます。&lt;/p&gt;

&lt;p&gt;具体的にはこんな感じで、分割を維持したまま各シェルを入れ換え可能です。
&lt;img src=&#34;http://ota42y.com/images/blog/2015/2015-07-06-tmux.png&#34; alt=&#34;2015-07-06-tmux.png&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;入れ替えはswap-paneを利用しています。&lt;br /&gt;
&lt;a href=&#34;https://github.com/abicky/swap-pane&#34;&gt;https://github.com/abicky/swap-pane&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;gemのannotateが便利:26038bc9325a7e1e74b9ae9d9fc662f9&#34;&gt;gemのAnnotateが便利&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ctran/annotate_models&#34;&gt;https://github.com/ctran/annotate_models&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DBからSchemaを読み取り、対応するモデルが書かれたファイルにその情報を書き込むgemです。&lt;br /&gt;
このモデルにどんなカラムがあったっけ？って時に、schemeファイルから探し出す必要がなくなるので大変便利です。&lt;br /&gt;
また、情報はコメントに追加されるため、既存のコードの邪魔になったり勝手にアクセサが追加されたりしないのも便利です。&lt;/p&gt;

&lt;h1 id=&#34;emacsのパッケージ管理:26038bc9325a7e1e74b9ae9d9fc662f9&#34;&gt;emacsのパッケージ管理&lt;/h1&gt;

&lt;p&gt;現在私のemacsはpackage.el、el-get、init-loaderの3つを使ってパッケージ管理をしています。&lt;br /&gt;
package.el、el-getがパッケージのDLや読み込み、init-loaderが設定ファイルのロードをしています。&lt;/p&gt;

&lt;p&gt;具体的な使い方はググれば解るので省略するとして、使い分けとこの構成になった理由は以下の通りです。&lt;/p&gt;

&lt;p&gt;なお、以下のリポジトリに設定ファイルが置いてあります。
&lt;a href=&#34;https://github.com/ota42y/dotfiles&#34;&gt;https://github.com/ota42y/dotfiles&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;パッケージ本体の管理:26038bc9325a7e1e74b9ae9d9fc662f9&#34;&gt;パッケージ本体の管理&lt;/h2&gt;

&lt;p&gt;まず、package.elはMELPA等専用なため、そこにあるパッケージはこちらで管理します。&lt;br /&gt;
一方で、githubや個別のgitリポジトリで管理されているものはel-getでrecipeを書いて管理しています。&lt;br /&gt;
機能的にはel-getだけで完結しますが、package.elの方が楽なので基本はpackage.el、&lt;br /&gt;
そこでカバーできないものをel-getで管理させています。&lt;/p&gt;

&lt;p&gt;また、これらで管理されているものは自動でロードされるようになっているため、&lt;br /&gt;
設定ファイルに追加するだけでインストールが完了します。&lt;/p&gt;

&lt;h2 id=&#34;パッケージ設定の管理:26038bc9325a7e1e74b9ae9d9fc662f9&#34;&gt;パッケージ設定の管理&lt;/h2&gt;

&lt;p&gt;init-loderを使うことで、特定フォルダ内の設定ファイルを一気に読み込むことが出来ます。&lt;br /&gt;
このため、気軽に設定ファイルを分割できます。&lt;/p&gt;

&lt;p&gt;ファイル名に数字を入れる事で読み込む順番の設定も出来るため、&lt;br /&gt;
package.elがダウンロードし、読み込みが終了してからパッケージの設定ファイルを読み込むように設定しています。&lt;/p&gt;

&lt;p&gt;また、私の環境では、el-getでinit-loaderを管理しているため、&lt;br /&gt;
el-get&amp;gt;init-loder&amp;gt;package.el&amp;gt;その他の設定ファイルの順で実行をしています。&lt;br /&gt;
el-getも自動インストールするようにしているため、設定ファイルを持って行くだけで全て自動でインストールできます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:26038bc9325a7e1e74b9ae9d9fc662f9&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;recipeに追加（必要なら）&lt;/li&gt;
&lt;li&gt;使用するパッケージを追加する

&lt;ul&gt;
&lt;li&gt;package.elの場合&lt;/li&gt;
&lt;li&gt;init-loderから読まれるpackage.el用の設定ファイル&lt;/li&gt;
&lt;li&gt;無ければ自動で読み込む&lt;/li&gt;
&lt;li&gt;el-getの場合&lt;/li&gt;
&lt;li&gt;emacs.dのinit.elに名前を書く&lt;/li&gt;
&lt;li&gt;recipeを元にDLする&lt;/li&gt;
&lt;li&gt;自動で読み込みも行われる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;設定をconf下に書く

&lt;ul&gt;
&lt;li&gt;init-loderが読み込む&lt;/li&gt;
&lt;li&gt;カスタマイズが必要ならば&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2015年26週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-26/</link>
      <pubDate>Mon, 29 Jun 2015 22:17:29 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-26/</guid>
      <description>

&lt;h1 id=&#34;fluentd-forwarderのビルドの仕組み:fb0b111ab341d72273c19a831f63e0c6&#34;&gt;fluentd-forwarderのビルドの仕組み&lt;/h1&gt;

&lt;p&gt;基本はREADMEの通りにすればビルド出来ますが、やっていることがちょっと複雑なのでメモ。&lt;br /&gt;
&lt;a href=&#34;https://github.com/fluent/fluentd-forwarder&#34;&gt;https://github.com/fluent/fluentd-forwarder&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;READMEに書いてある一つ目の手順の、&lt;br /&gt;
&lt;code&gt;go get github.com/fluent/fluentd-forwarder/entrypoints/build_fluentd_forwarder&lt;/code&gt;&lt;br /&gt;
で、GOPATH以下にリポジトリがcloneし、&lt;br /&gt;
entrypoints/build_fluentd_forwarder内のビルド作業用バイナリが作られます。&lt;/p&gt;

&lt;p&gt;次に、&lt;code&gt;bin/build_fluentd_forwarder fluentd_forwarder&lt;/code&gt;を実行することで、&lt;br /&gt;
さっき作ったbuild_fluentd_forwarderが&lt;code&gt;go get -u&lt;/code&gt;を実行し、&lt;br /&gt;
リポジトリをcloneして(既にしているけど)、entrypoints/fluentd_forwarder下をビルドします。&lt;/p&gt;

&lt;p&gt;というわけで、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;go getでbuild_fluentd_forwarderをビルドする&lt;/li&gt;
&lt;li&gt;build_fluentd_forwarderがgo getでfluentd_forwarderをビルドする。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という流れになっています。&lt;/p&gt;

&lt;h1 id=&#34;fluentd-forwarderに手を加えてみる:fb0b111ab341d72273c19a831f63e0c6&#34;&gt;fluentd-forwarderに手を加えてみる&lt;/h1&gt;

&lt;h2 id=&#34;ローカルで変更する場合:fb0b111ab341d72273c19a831f63e0c6&#34;&gt;ローカルで変更する場合&lt;/h2&gt;

&lt;p&gt;fluentd-forwarderに手を加えたい場合、GOPATH下のfluent/fluentd-forwarderを書き換えてビルドするのが最も早い方法です。&lt;br /&gt;
build_fluentd_forwarderがcloneしますが、変更はそのままでビルド出来ます。&lt;/p&gt;

&lt;h2 id=&#34;forkしたリポジトリに変更を加える場合:fb0b111ab341d72273c19a831f63e0c6&#34;&gt;Forkしたリポジトリに変更を加える場合&lt;/h2&gt;

&lt;p&gt;Forkしてそこに対して変更をした場合、若干やっかいな事が起きます。&lt;/p&gt;

&lt;p&gt;前述したように、build_fluentd_forwarderはgo getを使い、リポジトリをクローンしてビルドします。&lt;br /&gt;
そのため、build_fluentd_forwarderの中に書いてあるリポジトリを書き換え、自分のリポジトリに変更する必要があります。&lt;/p&gt;

&lt;p&gt;また、entrypoints/fluentd_forwarderはリポジトリルートのファイルを外部ライブラリとしてインポートしています。&lt;br /&gt;
そのため、main.goでfluent/fluentd_folwarderをインポートしている部分も、自分のリポジトリに変更する必要があります。&lt;/p&gt;

&lt;p&gt;以上の変更を加えることで、Forkした自分のリポジトリからビルドすることが出来ます。&lt;/p&gt;

&lt;p&gt;まとめると以下のの2ステップになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;build_fluentd_forwarder内のリポジトリを書き換える

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fluent/fluentd-forwarder/blob/master/entrypoints/build_fluentd_forwarder/main.go&#34;&gt;https://github.com/fluent/fluentd-forwarder/blob/master/entrypoints/build_fluentd_forwarder/main.go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ImportPathBaseを書き換える&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;fluent/fluentd_forwarderをインポートしている部分を書き換える

&lt;ul&gt;
&lt;li&gt;entrypoints/fluentd_forwarder以下の2ファイル共&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者はbueild_fluentd_forwarderを変えれば何とかなりそうですが、&lt;br /&gt;
後者はgoのimportの仕組みがリポジトリ名まで指定する仕組みのため、書き換える以外に良い解決方法が思いつきません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年25週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-25/</link>
      <pubDate>Mon, 22 Jun 2015 22:09:20 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-25/</guid>
      <description>

&lt;h1 id=&#34;go-conに参加していた:4120373b776e428195f8931ca37ff809&#34;&gt;go conに参加していた&lt;/h1&gt;

&lt;p&gt;去年の秋と比べて、実際に使っている例が多くて、&lt;br /&gt;
もうプロダクション投入されてるなーという印象でした。
&lt;a href=&#34;http://ota42y.com/blog/2015/06/21/gocon-2015-summer/&#34;&gt;参加記録 Go Conference 2015 summer&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;atom-ioは辞めた:4120373b776e428195f8931ca37ff809&#34;&gt;atom.ioは辞めた&lt;/h1&gt;

&lt;p&gt;Atom.ioの現状の仕様は、プロジェクトごとにウィンドウを割り当てて使うようになっています。&lt;br /&gt;
ですが、MacではWindowsに比べて同じアプリ内のウィンドウを切り替えるのがとても大変であり、&lt;br /&gt;
このようにウィンドウを細かく分けられると著しく不便です。&lt;br /&gt;
Macのひどい仕様に負けるのはあまり良い気分ではないですが、&lt;br /&gt;
このあたりの仕様が変わるまでは私の使い方では使い物になりません…&lt;/p&gt;

&lt;p&gt;また、立ち上がりが重いのも大きな問題の1つです。&lt;br /&gt;
ビルド中はCPUをものすごく使っているおり、その状態でAtom.ioを立ち上げると起動まで十数秒かかります。&lt;br /&gt;
ただこの点に関しては、ネィティブではなくwebエンジニアであれば問題にならないとは思います。&lt;/p&gt;

&lt;h1 id=&#34;gosweepが便利そう:4120373b776e428195f8931ca37ff809&#34;&gt;gosweepが便利そう&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hailiang/gosweep&#34;&gt;https://github.com/hailiang/gosweep&lt;/a&gt;&lt;br /&gt;
gofmtやgolint等のgoの便利ツールを全て実行してくれる奴です。&lt;br /&gt;
便利＆go vetやgoimports等知らないのもあったので有用そうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年24週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-24/</link>
      <pubDate>Mon, 15 Jun 2015 22:37:01 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-24/</guid>
      <description>

&lt;h1 id=&#34;c-入出力の書式を制御する:b0204dc6a3868861d55079e7791d2606&#34;&gt;C++入出力の書式を制御する&lt;/h1&gt;

&lt;p&gt;c++でstreamを使って出力する場合、iomanipに用意されているものを利用することで、&lt;br /&gt;
入出力の書式を制御することが出来ます。&lt;/p&gt;

&lt;p&gt;設定はstreamに対して設定用のオブジェクトを送るように設定するみたいです。&lt;br /&gt;
なお、以下は出力の例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

int main(void) {
  double a = 25252;
  int p = 2;

  std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; // 25252
  std::cout &amp;lt;&amp;lt; std::setprecision(p); //浮動小数点の有効桁数を指定する
  std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; // 2.5e+04

  std::cout &amp;lt;&amp;lt; std::oct; // 8進数表示
  std::cout &amp;lt;&amp;lt; 874 &amp;lt;&amp;lt; std::endl; // 1552

  std::cout &amp;lt;&amp;lt; std::showbase; // 基数を表示する
  std::cout &amp;lt;&amp;lt; std::hex; // 16進数表示
  std::cout &amp;lt;&amp;lt; 874 &amp;lt;&amp;lt; std::endl; // 0x36a
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>2015年23週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-23/</link>
      <pubDate>Mon, 08 Jun 2015 23:41:38 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-23/</guid>
      <description>

&lt;h1 id=&#34;lock-freeって何:b762442d260e082e6120a3e456dc065a&#34;&gt;Lock Freeって何&lt;/h1&gt;

&lt;p&gt;複数スレッドや複数コアから同じデータを更新する場合、&lt;br /&gt;
通常はlockをかけて排他制御を行いますが、lockをかけずに行う方法があるらしいです。&lt;/p&gt;

&lt;p&gt;lockをかける場合、その間そのデータにはアクセスできず、並列処理を止めてしまうため、&lt;br /&gt;
並列数が大きくなるに従って性能が劣化していくそうです。&lt;br /&gt;
lockなしで排他処理を行う場合、並列数を増やしても性能の劣化が無くなるそうです。&lt;/p&gt;

&lt;p&gt;やっていることとしては、値をコピーして変更を加え、&lt;br /&gt;
「コピー前の値と現在の値が一緒かどうかをチェック」「変更した値を書き込む」を一括にやる命令を利用し、&lt;br /&gt;
比較と更新を同時にするというものだそうです。&lt;br /&gt;
(Compare-and-Swap、CAS命令)&lt;/p&gt;

&lt;p&gt;この比較して更新する命令があることで、&lt;br /&gt;
ロックせずに複数から値を変更しても一貫性が保たれるらしいです。&lt;br /&gt;
また、この命令が無いとlock freeが実現できない事が証明されているらしいです。&lt;br /&gt;
 &lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%9A%E3%82%A2%E3%83%BB%E3%82%A2%E3%83%B3%E3%83%89%E3%83%BB%E3%82%B9%E3%83%AF%E3%83%83%E3%83%97&#34;&gt;コンペア・アンド・スワップ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;i386ではCMPXCHG〜命令でこれが出来るらしく、&lt;br /&gt;
goのatomicパッケージでも利用されているようです。&lt;br /&gt;
&lt;a href=&#34;https://github.com/golang/go/blob/master/src/sync/atomic/asm_386.s#L34&#34;&gt;https://github.com/golang/go/blob/master/src/sync/atomic/asm_386.s#L34&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年22週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-22/</link>
      <pubDate>Mon, 01 Jun 2015 22:00:39 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-22/</guid>
      <description>

&lt;p&gt;今週まとめ&lt;/p&gt;

&lt;h1 id=&#34;cでのマルチスレッド処理を調べてる:68ba6b064e3726dd0f45c78184617ab0&#34;&gt;Cでのマルチスレッド処理を調べてる&lt;/h1&gt;

&lt;p&gt;Cにはクラスが無いので、Threadクラスを継承し、&lt;br /&gt;
runメソッドをオーバーライドするといった、いろんな言語でよくあるパターンは使えません。&lt;br /&gt;
代わりに、pthread_create関数にコールバック関数を渡すと、&lt;br /&gt;
別スレッドから呼び出してくれるため、それを利用して別スレッドを作るようです。&lt;/p&gt;

&lt;h1 id=&#34;cでのロック処理を調べている:68ba6b064e3726dd0f45c78184617ab0&#34;&gt;Cでのロック処理を調べている&lt;/h1&gt;

&lt;p&gt;ロック用変数を作り、pthread_mutex_lock関数を呼ぶことで、ロックをかけられます。&lt;/p&gt;

&lt;p&gt;他のスレッドから起こされるまで待つには、&lt;br /&gt;
mutexとcond変数を定義して、mutexのロックを取得して、&lt;br /&gt;
pthread_cond_waitを呼びます。&lt;/p&gt;

&lt;p&gt;一定時間たったら呼ばれて無くても起きて欲しい場合は、&lt;br /&gt;
pthread_cond_timedwaitを呼びます。&lt;/p&gt;

&lt;p&gt;なお、C++11からmutexオブジェクトといった、&lt;br /&gt;
ロックや排他制御が簡単にできる仕組みが導入されています。&lt;/p&gt;

&lt;h1 id=&#34;c-ではintに-演算が出来る:68ba6b064e3726dd0f45c78184617ab0&#34;&gt;C++ではintに[]演算が出来る&lt;/h1&gt;

&lt;p&gt;元ネタ&lt;br /&gt;
&lt;a href=&#34;http://twitter.com/mattn_jp/status/605245747429179392&#34;&gt;http://twitter.com/mattn_jp/status/605245747429179392&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;memory.h&amp;gt;

int main() {
  int v[] = {1, 2, 3};
  int off = 2;
  printf(&amp;quot;%d\n&amp;quot;, off[v]); // 3
  printf(&amp;quot;%d\n&amp;quot;, 1[v]); // 2
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++では、intやenum型に対して[]が実行された場合、暗黙的な方変換によりstd::ptrdiff_tに変換されます。&lt;br /&gt;
そのため、a[b]は&lt;code&gt;*(a+b)&lt;/code&gt;と同義になり、上の例は&lt;code&gt;*(off+v)&lt;/code&gt;や&lt;code&gt;*(1+v)&lt;/code&gt;と解釈され、
正しく動くようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/operator_member_access&#34;&gt;http://en.cppreference.com/w/cpp/language/operator_member_access&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年21週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-21/</link>
      <pubDate>Mon, 25 May 2015 22:09:32 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-21/</guid>
      <description>

&lt;h1 id=&#34;体調を崩した:63b972d7b8a9e5b8ecb6903994a97d8c&#34;&gt;体調を崩した&lt;/h1&gt;

&lt;p&gt;体調を崩して週の半分は倒れてた。&lt;br /&gt;
3日倒れるとやることリストが大変なことになるので、&lt;br /&gt;
体調がおかしい場合は速やかに医者に行って、薬をもらうべきだと再認識した。&lt;/p&gt;

&lt;h1 id=&#34;c-03以前ではオーバーロードされたコンストラクタが呼び出せない:63b972d7b8a9e5b8ecb6903994a97d8c&#34;&gt;C++03以前ではオーバーロードされたコンストラクタが呼び出せない&lt;/h1&gt;

&lt;p&gt;以下のように、コンストラクタから別のコンストラクタを呼び出すことで、&lt;br /&gt;
処理を共通化するのはわりと自然ではないかと思います。&lt;/p&gt;

&lt;p&gt;これはdelegate constructorとうい名前がついており、&lt;br /&gt;
残念ながらC++11以降じゃないと使えません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {
  A() : A(0) {}
  A(int num) : a(num) {}
  int a;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>2015年20週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-20/</link>
      <pubDate>Mon, 18 May 2015 21:40:28 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-20/</guid>
      <description>

&lt;h1 id=&#34;一週間何もしていないことが可視化される:aa9a80d3c7f9b6c9852a691c72ac9714&#34;&gt;一週間何もしていないことが可視化される&lt;/h1&gt;

&lt;p&gt;毎週先週やったことをまとめているので、&lt;br /&gt;
先週何もしていないのが可視化される…&lt;/p&gt;

&lt;h1 id=&#34;prマージされた:aa9a80d3c7f9b6c9852a691c72ac9714&#34;&gt;PRマージされた&lt;/h1&gt;

&lt;p&gt;fluentd-forwarderに送っていたPRがマージされた。&lt;br /&gt;
&lt;a href=&#34;https://github.com/fluent/fluentd-forwarder/pull/10&#34;&gt;https://github.com/fluent/fluentd-forwarder/pull/10&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;が、テストのバグでテストが通らないとの指摘が。&lt;br /&gt;
ただし、手元のMacやLinuxでは通るので、Windowsだけの問題っぽいです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年19週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-19/</link>
      <pubDate>Mon, 11 May 2015 21:55:04 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-19/</guid>
      <description>

&lt;h1 id=&#34;atomicな処理でアライメントを揃える必要があるらしい:732daa6ed2fb5abdbd55e43c0c719906&#34;&gt;atomicな処理でアライメントを揃える必要があるらしい&lt;/h1&gt;

&lt;p&gt;goのatomic.AddInt64や、&lt;br /&gt;
WindowsのInterlockedExchangeでは、&lt;br /&gt;
32bit環境で64bitの値をアトミックに変更する場合、&lt;br /&gt;
その値が64bit境界に置かれている必要があるらしいです。&lt;br /&gt;
ですが、何故それが必要なのかを調べているのですが、それらしい理由が見つかりません…&lt;/p&gt;

&lt;p&gt;一応、Intelのアーキテクチャには、ロックをせずに変更する場合、&lt;br /&gt;
64bitアライメントに乗っていない場合はアトミックな処理が保証されないと書いてありましたが、&lt;br /&gt;
goではロックしてからCMPXCHG8Bを実行しており、アトミックな処理になるはずです。&lt;/p&gt;

&lt;p&gt;また、ロックやCMPXCHG8Bもメモリアライメントの制約は受けないため、特に問題は無さそうです。&lt;/p&gt;

&lt;p&gt;一応、64bit境界に無い場合は性能が低下する可能性があるそうですが…&lt;/p&gt;

&lt;h1 id=&#34;android-触ってた:732daa6ed2fb5abdbd55e43c0c719906&#34;&gt;Android 触ってた&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;string.xmlは同じフォルダに別の名前のxmlを作っても、勝手にまとめてくれるので同じようにアクセスできるみたい。&lt;/li&gt;
&lt;li&gt;Dropbox SDKを触ってみた

&lt;ul&gt;
&lt;li&gt;サンプルがかなり良い具合に出来ている&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UIを変更できるのは描画用のスレッドだけ

&lt;ul&gt;
&lt;li&gt;doInBackgroundは別スレッドで処理を行う&lt;/li&gt;
&lt;li&gt;UIを変更しようとすると落ちる&lt;/li&gt;
&lt;li&gt;終了時にonPostExecuteがUIスレッドで呼ばれるのでそこで処理する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;fluentdを触ってる:732daa6ed2fb5abdbd55e43c0c719906&#34;&gt;fluentdを触ってる&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;自分用のアプリのログ処理を入れ換えた&lt;/li&gt;
&lt;li&gt;windowsとlinuxそれぞれあるけど、fluentd-forwarderを使ってlinuxのfluentdに集約&lt;/li&gt;
&lt;li&gt;windowsはrubyで書いてる

&lt;ul&gt;
&lt;li&gt;ruby2.1じゃないと動かない

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/okahashi117/items/a0b55ea24a6ef7b6582b&#34;&gt;http://qiita.com/okahashi117/items/a0b55ea24a6ef7b6582b&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;msgpackは未対応&lt;/li&gt;
&lt;li&gt;オプションが渡せないため、bundlerも使えない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SSL接続に失敗する

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/luislavena/f064211759ee0f806c88&#34;&gt;https://gist.github.com/luislavena/f064211759ee0f806c88&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ここのpemファイルの位置をSSL_CERT_FILE環境変数に設定する必要がある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;fluentd-forwarder-にpr送った:732daa6ed2fb5abdbd55e43c0c719906&#34;&gt;fluentd-forwarder にPR送った&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;atomic処理のメモリアライメント的な問題でwindows 32bitだと動かなかったので直した

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fluent/fluentd-forwarder/pull/10&#34;&gt;https://github.com/fluent/fluentd-forwarder/pull/10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;まだマージされてないので、手元のブランチでビルドしたものを使ってる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;goのパッケージシステムは手元で動かすのとものすごく相性が悪い

&lt;ul&gt;
&lt;li&gt;全てのパッケージバスを自分のリポジトリに書き換えないといけない&lt;/li&gt;
&lt;li&gt;しかもmasterブランチ限定&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2015年18週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-18/</link>
      <pubDate>Mon, 04 May 2015 11:27:52 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-18/</guid>
      <description>

&lt;h1 id=&#34;goのテストはクラス設計がとても大事っぽい:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;goのテストはクラス設計がとても大事っぽい&lt;/h1&gt;

&lt;p&gt;まだこうした方が良いんじゃないか？ぐらいなので、&lt;br /&gt;
ベストプラクティスは他にありそうです…&lt;/p&gt;

&lt;h2 id=&#34;rubyで関数の差し替え:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;rubyで関数の差し替え&lt;/h2&gt;

&lt;p&gt;Rubyだと以下のように、&lt;br /&gt;
すでに存在するクラスに対して関数を再定義したり、&lt;br /&gt;
継承して関数の差し替えをすることが簡単にできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;
class A
  def exec
    f()
    a()
  end

  def f
    print &amp;quot;f &amp;quot;
  end

  def a
    print &amp;quot;a\n&amp;quot;
  end
end

a = A.new
a.exec # f a

class A
  def f
    print &amp;quot;newf &amp;quot;
  end
end

a.exec #newf a

class B &amp;lt; A
  def f
    print &amp;quot;newf &amp;quot;
  end
end

b = B.new
b.exec #newf a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのため、一部の関数をモックやスタブにし、正しく呼び出されているかを検証したり、&lt;br /&gt;
その機能以外のところがちゃんと動いているかを検証するのが簡単にできます。&lt;/p&gt;

&lt;h2 id=&#34;goで関数の差し替え:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;goで関数の差し替え&lt;/h2&gt;

&lt;h3 id=&#34;埋め込みによる差し替え-できない:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;埋め込みによる差し替え（できない）&lt;/h3&gt;

&lt;p&gt;golangでは既存の構造体に関数を再定義することはできません。&lt;br /&gt;
また、以下のrubyコードのように埋め込んだ後に関数を再定義しても、&lt;br /&gt;
継承前の関数を読んでいる部分を差し替えることはできません。&lt;/p&gt;

&lt;p&gt;そのため、rubyの2番目の例のような以下のコードでは、&lt;br /&gt;
&lt;code&gt;b.Exec&lt;/code&gt;はAの関数fを呼び出してしまうため、動きを差し替えられません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type A struct {
}

func (a *A) Exec() {
	a.f()
	a.a()
}

func (a *A) f() {
	fmt.Print(&amp;quot;f &amp;quot;)
}

func (a *A) a() {
	fmt.Print(&amp;quot;a\n&amp;quot;)
}

type B struct {
	*A
}

func (a *B) f() {
	fmt.Print(&amp;quot;newf &amp;quot;)
}

func main() {
	a := &amp;amp;A{}
	a.Exec() // f a

	b := &amp;amp;B{
		A: a,
	}
	b.Exec() // f a (not &amp;quot;newf a&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;インターフェースを利用する:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;インターフェースを利用する&lt;/h3&gt;

&lt;p&gt;golangにはインターフェースが合っていれば何でも代入できるため、&lt;br /&gt;
インターフェースを呼び出すように実装し、わたす構造体を変えることで、&lt;br /&gt;
関数の差し替えをすることができるようになります。&lt;/p&gt;

&lt;p&gt;以下の例では計算用のCalcというインタフェースを定義し、&lt;br /&gt;
実際に計算を行うSumAddと、固定の値を返したり渡された値を見えるようにしたSumTestを用意しています。&lt;br /&gt;
SmuTestを利用することで、呼び出し側のAのロジックが正しいかを検証できるようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type A struct {
  calc Calc
  list []int
}

func (a *A) F(ratio float64) float64 {
  s := a.calc.sum(a.list)
  return float64(s) * ratio
}

type Calc interface {
  sum(l []int) int
}

type SumAdd struct{
}

func (s *SumAdd) sum(l []int) int {
  sum := 0
  for _, i := range l {
    sum += i
  }
  return sum
}

type SumTest struct {
  Nums []int
}

func (s *SumTest) sum(l []int) int {
  s.Nums = l
  return 15
}

func main() {
  s := &amp;amp;SumAdd{}
  l := []int{1,2,3,4,5}

  a := &amp;amp;A{
    calc: s,
    list: l,
  }
  fmt.Println(a.F(3.0))

  t := &amp;amp;SumTest{}
  testA := &amp;amp;A{
    calc: t,
    list: l,
  }

  ret := testA.F(3.0)
  fmt.Println(ret == 45)
  fmt.Println(len(t.Nums) == 5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;golangではインタフェースを利用して挙動を変えることで、部分的にテストができます。&lt;br /&gt;
ただし、設計時にどこをインターフェースにするかを考えて作らないと、上手く差し替えができません。&lt;/p&gt;

&lt;p&gt;つまり、rubyは適当に作ったテストしにくい設計でも無理矢理テストできますが、&lt;br /&gt;
golangはテストしやすい設計を考えてから作る必要があるようです。&lt;/p&gt;

&lt;h1 id=&#34;bpstudy-92に参加した:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;BPStudy#92に参加した&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;blog/2015/04/29/bpstudy92/&#34;&gt;参加記録 BPStudy#92&lt;/a&gt;
お金の話でした。&lt;br /&gt;
経営や簿記は全く本業ではないのですが、自分が生きてる世界を構成する重要な要素なので、&lt;br /&gt;
知っておいた方が良いと思いました。&lt;/p&gt;

&lt;h1 id=&#34;mongodbについて調べていた:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;mongodbについて調べていた&lt;/h1&gt;

&lt;h2 id=&#34;一定時間後にデータが消える設定:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;一定時間後にデータが消える設定&lt;/h2&gt;

&lt;p&gt;容量節約のため、一定期間後のデータは消えるようにしたいなーと思っていたところ、&lt;br /&gt;
時間の入っているキーに対してexpireAfterSecondsのついたTTL(time to live)インデックスを作ることで、&lt;br /&gt;
指定時刻経過後に消されるようにできるみたいです。&lt;br /&gt;
&lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/expire-data/&#34;&gt;Expire Data from Collections by Setting TTL&lt;/a&gt;&lt;br /&gt;
また、このインデックスはそのまま時刻付きのインデックスとしても利用できるそうです。&lt;/p&gt;

&lt;h2 id=&#34;指定した期間のデータをdumpする:fbc8528214e49b0085aa07c0c8b68dfd&#34;&gt;指定した期間のデータをdumpする&lt;/h2&gt;

&lt;p&gt;mongodumpでは-qオプションでクエリを指定できるため、&lt;br /&gt;
そこで時刻を指定することで指定した期間のデータをdumpできます。&lt;/p&gt;

&lt;p&gt;ただし、どうやらISODateはコマンドラインからは上手く動かないらしく、&lt;br /&gt;
Dateオブジェクトを利用してミリ秒で指定する必要があるようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mongodump --host localhost --db testdb -q \&amp;quot;{time : { \\$gte :  new Date(1430000000000), \\$lt :  new Date(1440000000000) } }\&amp;quot; -o dump/2015-05-04
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>2015年17週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-17/</link>
      <pubDate>Mon, 27 Apr 2015 11:58:59 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-17/</guid>
      <description>

&lt;h1 id=&#34;cpplintが便利そう:4d6f6f3ae9acaa6b2b7ea721f3040303&#34;&gt;cpplintが便利そう&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/AtomLinter/linter-cpplint&#34;&gt;AtomLinter/linter-cpplint&lt;/a&gt;&lt;br /&gt;
Google Style Guideに沿っているかをチェックしてくれるcpplintを、&lt;br /&gt;
Atom.ioから使えるようにしているPluginです。&lt;/p&gt;

&lt;p&gt;めっちゃ便利なのですが、標準だとcpplintのフィルターしか設定できず、&lt;br /&gt;
他のオプションを設定できないため、PRを送りました。&lt;br /&gt;
&lt;a href=&#34;https://github.com/AtomLinter/linter-cpplint/pull/12&#34;&gt;https://github.com/AtomLinter/linter-cpplint/pull/12&lt;/a&gt;&lt;br /&gt;
レビュー待ちです(o゜▽゜)&lt;/p&gt;

&lt;h1 id=&#34;apple-watch買った:4d6f6f3ae9acaa6b2b7ea721f3040303&#34;&gt;Apple Watch買った&lt;/h1&gt;

&lt;p&gt;たまたま発売日に秋葉原を歩いていたら売っていたのでつい買ってしまいました。&lt;br /&gt;
が、iPhoneをメインで使っているわけではないので、いまいち使い道が良くわからないです。&lt;br /&gt;
しばらくは見せるようですかね…&lt;/p&gt;

&lt;h1 id=&#34;fluentd-forwarderを触ってた:4d6f6f3ae9acaa6b2b7ea721f3040303&#34;&gt;fluentd-forwarderを触ってた&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fluent/fluentd-forwarder&#34;&gt;fluent/fluentd-forwarder&lt;/a&gt;&lt;br /&gt;
Windowsのサーバで動かしているやつのログをとってくるの面倒だなー&lt;br /&gt;
と思っていたので、便利そうです(o゜▽゜)&lt;br /&gt;
とりあえず動かし方はわかったので、実際に入れてみようかと…&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年16週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-16/</link>
      <pubDate>Mon, 20 Apr 2015 07:36:53 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-16/</guid>
      <description>

&lt;h1 id=&#34;goの開発環境充実中:bf182f6030fd736d27d619234da1a3e4&#34;&gt;goの開発環境充実中&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;go fmt

&lt;ul&gt;
&lt;li&gt;goのフォーマットをぱぱっと修正してくれます。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;golint

&lt;ul&gt;
&lt;li&gt;動作に影響ないが推奨されないような部分を指摘し、何をすべきかを教えてくれます。&lt;/li&gt;
&lt;li&gt;goのコーディング規約に沿っていないチェックが主です&lt;/li&gt;
&lt;li&gt;IntelliJから使えれば最高なんですが…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、goの公式ではないですが、以下のテスティングツールが便利そうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;goconvey

&lt;ul&gt;
&lt;li&gt;テストの自動実行&lt;/li&gt;
&lt;li&gt;go testの結果をブラウザで見やすくしてくれる&lt;/li&gt;
&lt;li&gt;標準のテストを拡張したテストライブラリとしての機能もある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IntelliJ IDEA

&lt;ul&gt;
&lt;li&gt;go pluginを入れると凄い便利&lt;/li&gt;
&lt;li&gt;Windowsの場合はVM上のLinuxに立てて、ネットワークドライブでアクセスするといい

&lt;ul&gt;
&lt;li&gt;goconveyをLinuxで動かしてブラウザで見る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;勉強会参加:bf182f6030fd736d27d619234da1a3e4&#34;&gt;勉強会参加&lt;/h1&gt;

&lt;p&gt;家にこもると良いことないので、わりと勉強会に出てました。&lt;br /&gt;
だいたい行く前はめんどくさいなーとか、行っても意味ないんじゃ…みたいになるけど、&lt;br /&gt;
いざ行くとかなり満足するし、有用な情報が手に入るので難しいです…&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;blog/2015/04/14/golang-no-http-night/&#34;&gt;参加記録 GolangNotHttpNight（Gunosy.go#12&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;blog/2015/04/19/game-server-4/&#34;&gt;参加記録 第四回　ゲームサーバ勉強会&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;タスク管理アプリ作ってる:bf182f6030fd736d27d619234da1a3e4&#34;&gt;タスク管理アプリ作ってる&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;v0.0.1出した

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ota42y/plaintodo/releases/tag/v0.0.1&#34;&gt;https://github.com/ota42y/plaintodo/releases/tag/v0.0.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;タスク閲覧機能のみ&lt;/li&gt;
&lt;li&gt;次はタスク追加機能とかつける&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2015年15週目まとめ</title>
      <link>http://ota42y.com/pages/summary/2015/week-15/</link>
      <pubDate>Mon, 13 Apr 2015 11:53:02 +0900</pubDate>
      
      <guid>http://ota42y.com/pages/summary/2015/week-15/</guid>
      <description>

&lt;h1 id=&#34;atom-ioのstarでパッケージ管理:d98e074c42c4bcd9d2f6d106cbfe320e&#34;&gt;Atom.ioのstarでパッケージ管理&lt;/h1&gt;

&lt;p&gt;Atom.ioでは、パッケージのページ上でそのパッケージにスターをつけることができます。&lt;br /&gt;
&lt;a href=&#34;https://atom.io/packages/project-manager&#34;&gt;https://atom.io/packages/project-manager&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここでスターをつけたパッケージはユーザのお気に入り扱いになり、&lt;br /&gt;
ユーザページ(例: &lt;a href=&#34;https://atom.io/users/ota42y&#34;&gt;https://atom.io/users/ota42y&lt;/a&gt; )上で確認できます。&lt;/p&gt;

&lt;p&gt;さらに、Atom.ioにはapmというパッケージ管理システムがついており、&lt;br /&gt;
これにstarsオプションを与えることで一覧を見ることや、&lt;code&gt;apm stars --install&lt;/code&gt;で、&lt;br /&gt;
ユーザのスターをつけたパッケージをすべてインストールできます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/atom/apm/blob/master/src/stars.coffee&#34;&gt;https://github.com/atom/apm/blob/master/src/stars.coffee&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;プラグインのバックアップはもちろんのこと、複数環境でのプラグイン同期にとても便利なので重宝します。&lt;/p&gt;

&lt;h1 id=&#34;タスク管理システム作ってる:d98e074c42c4bcd9d2f6d106cbfe320e&#34;&gt;タスク管理システム作ってる&lt;/h1&gt;

&lt;p&gt;最低限表示するだけのver. 0.0.1ができそうです。&lt;br /&gt;
&lt;a href=&#34;https://github.com/ota42y/plaintodo&#34;&gt;https://github.com/ota42y/plaintodo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;対話型インタフェースを作るのにlinerが凄い便利でした。&lt;br /&gt;
&lt;a href=&#34;http://ota42y.com/blog/2015/04/11/go-liner/&#34;&gt;golangのラインエディタはlinerが便利&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Travis.ciとか入れてCI回したいですが、テスト用コンテナでの依存パッケージの管理とか大変そうです…&lt;br /&gt;
godepやgomみたいなバージョン管理の導入を検討しますかね。&lt;/p&gt;

&lt;h1 id=&#34;第6回ニコニコ学会β-データ研究会に参加した:d98e074c42c4bcd9d2f6d106cbfe320e&#34;&gt;第6回ニコニコ学会β　データ研究会に参加した&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://ota42y.com/blog/2015/04/12/niconico_data_6/&#34;&gt;参加記録 第6回ニコニコ学会β　データ研究会&lt;/a&gt;&lt;br /&gt;
今回の基調講演も発表もとてもおもしろかったです。&lt;br /&gt;
特に人狼はそこそこやっているため、とても参考になりました。&lt;br /&gt;
deviantARTは存在を知らなかったので、いろいろ調べてみたいですね…&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>