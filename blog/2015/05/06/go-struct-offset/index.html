<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="description" content="Go言語でメモリ上の大きさや配置を調べる">
    <meta name="author" content="ota42y">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>
      hljs.configure({tabReplace: '    '}); 
      hljs.initHighlightingOnLoad();
    </script>

    
    <title>Go言語でメモリ上の大きさや配置を調べる | おおたの物置</title>
    

    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/list.css">
    <link rel="stylesheet" href="/css/single.css">
    <link rel="stylesheet" href="/css/index.css">
</head>


<body>

<div class="body">

    <div class="header_wrapper">
        <div class="content">
            <div class="header">
                <div class="header_left">
                    <a class="banner" href="/">おおたの物置</a>
                </div>
                <div class="header_right">
                    
                    <a href="https://twitter.com/ota42y">twitter</a>
                    

                    
                    <a href="https://github.com/ota42y">github</a>
                    
                    <a href="">RSS</a>
                </div>
            </div>
        </div>
    </div>

    <div class="content">
        <div class="main">

            <div class="article">

                <div class="post_title">
                    <h1>Go言語でメモリ上の大きさや配置を調べる</h1>
                    

<time datetime="2015-05-06" class="post_data">
2015-05-06
</time>





<div class="separator">|</div>
<div class="post_data">
    Category: <a href="/categories/tech">tech</a>
</div>




<div class="tags">
    <div class="separator">|</div>

    <div class="post_data">tags: [</div>

    
    <div class="post_data">
        <a href="/tags/golang">golang</a>
    </div>
    
    <div class="post_data">]</div>
</div>


                    <div class="clear"></div>
                </div>

                <div class="article_body">

                    
                    <div id="toc">
                        <div id="toc_body">
                            <div id="toc_index">目次</div>
                            <nav id="TableOfContents">
<ul>
<li><a href="#要素のサイズ:7df659e690576969cb149167507e359f">要素のサイズ</a></li>
<li><a href="#先頭からのオフセット:7df659e690576969cb149167507e359f">先頭からのオフセット</a></li>
<li><a href="#構造体内の構造体の場合:7df659e690576969cb149167507e359f">構造体内の構造体の場合</a></li>
<li><a href="#ソースコード:7df659e690576969cb149167507e359f">ソースコード</a></li>
</ul>
</nav>
                        </div>
                    </div>
                    

                    

<p>golangで構造体を定義した場合、
メモリ上にどのように配置されるのでしょうか。</p>

<p>通常意識する必要はありませんが、32bitと64bitで挙動がおかしい場合など、<br />
ごく希に調べる必要に迫られる場合があります。<br />
そのような場合、各要素のサイズや、構造体先頭からのオフセットを調べることで、<br />
メモリ上に構造体がどう置かれるかを調べることができます。</p>

<p>C言語でのsizeofやoffsetofに対応する物が、golangのunsafeパッケージに用意されているため、<br />
これを利用することで構造体の様子を調べることができます。<br />
<a href="https://golang.org/pkg/unsafe/">https://golang.org/pkg/unsafe/</a></p>

<p>今回は以下のようなテスト構造体を使い、メモリ上にどのように置かれるかを調べました。<br />
テスト環境はwindows7(32bit)とmac(64bit)になります。</p>

<pre><code class="language-go">type A struct {
  flag bool
  num int64
  ptr *int64
  mini int32
  str string
  nums []int64
  nums5 [5]int64
  strs []string
}
</code></pre>

<h1 id="要素のサイズ:7df659e690576969cb149167507e359f">要素のサイズ</h1>

<p>unsafe.Sizeof関数は、引数の要素のサイズを調べ、バイト数をint型で返してくれます。</p>

<pre><code class="language-go">a := A{}
log.Println(unsafe.Sizeof(a)) // 92 (136) 括弧外は32bit環境、括弧内は64bit
log.Println(unsafe.Sizeof(a.flag)) // 1
log.Println(unsafe.Sizeof(a.num)) // 8
log.Println(unsafe.Sizeof(a.ptr)) // 4 (8)
log.Println(unsafe.Sizeof(a.mini)) // 4
log.Println(unsafe.Sizeof(a.str)) // 8 (16)
log.Println(unsafe.Sizeof(a.nums)) // 12 (24)
log.Println(unsafe.Sizeof(a.nums5)) // 40
log.Println(unsafe.Sizeof(a.strs)) // 12 (24)

a.nums = append(a.nums, 42)
a.strs = append(a.strs, &quot;デーデッデー&quot;)
log.Println(unsafe.Sizeof(a.nums)) // 12 (24)
log.Println(unsafe.Sizeof(a.strs)) // 12 (24)

log.Println(unsafe.Sizeof(&amp;a)) // 4 (8)
</code></pre>

<p>この関数は指定した要素のサイズを返します。
そのため、32bit環境ではint64のポインタであるa.ptrは、<br />
ポインタのサイズである4byte(=32bit)を返します。</p>

<p>また、配列の場合は配列全体のサイズ(a.nums5 = 64 * 5)を返しますが、<br />
スライスの場合はスライス自身の値(12 or 24byte)を返し、スライス全体の値は返しません。<br />
そのため、要素を追加してもスライス自身の大きさは変化しません。</p>

<h1 id="先頭からのオフセット:7df659e690576969cb149167507e359f">先頭からのオフセット</h1>

<p>上記の例でbool値のa.flagが1byteかつ、ほかの要素がすべて偶数なのにもかかわらず、<br />
構造体全体の大きさが92byteの偶数になっています。<br />
このことから、golangの構造体はパディングされる場合があることがわかります。<br />
そのため、要素のサイズを足していったところが、実際にメモリ上に置かれる場所とは限りません。</p>

<p>構造体先頭からのオフセットが何byteかをint型で返す、unsafe.Offsetofを使うことで、<br />
実際にどの位置に配置されているかを確認できます。</p>

<pre><code class="language-go">log.Println(unsafe.Offsetof(a.flag)) // 0
log.Println(unsafe.Offsetof(a.num)) // 4 (8)
log.Println(unsafe.Offsetof(a.ptr)) // 12 (16)
log.Println(unsafe.Offsetof(a.mini)) // 16 (24)
log.Println(unsafe.Offsetof(a.str)) // 20 (32)
log.Println(unsafe.Offsetof(a.nums)) // 28 (48)
log.Println(unsafe.Offsetof(a.nums5)) // 40 (72)
log.Println(unsafe.Offsetof(a.strs)) // 80 (112)
</code></pre>

<p>32bit環境ではa.flagの1byteの後に3byteパディングがされ、<br />
a.numが先頭から4byte(=32bit)の位置から始まっています。</p>

<p>64bit環境ではa.flagの後ろに7byteパディングされ、<br />
a.numが先頭から8byte(=64bit)の位置から始まっています。<br />
また、int32のa.miniも4byteパディングされ、a.strが32byte目から始まるようになっています。</p>

<p>このように、32bit環境では32bitに、64bit環境では64bitの倍数から始まるように、<br />
コンパイラが構造体にパディングをするようです。</p>

<h1 id="構造体内の構造体の場合:7df659e690576969cb149167507e359f">構造体内の構造体の場合</h1>

<p>以下のように構造体に実態を持つ場合、宣言したとおりに配置されます。<br />
そのためAの実態であるaの前後で、構造体のサイズ分だけオフセットが移動しています。</p>

<pre><code class="language-go">type B struct {
  bflag bool
  intnum int64
  a A
  bflag2 bool
  a2 *A
  bflag3 bool
  A
  blfag4 bool
}
</code></pre>

<pre><code class="language-go">b := B{
  a2: &amp;A{},
}
log.Println(unsafe.Offsetof(b.bflag)) // 0
log.Println(unsafe.Offsetof(b.intnum)) // 4
log.Println(&quot;b.a&quot;)
log.Println(unsafe.Offsetof(b.a.flag)) // 0
log.Println(unsafe.Offsetof(b.a.strs)) // 80
log.Println(&quot;b.flag2&quot;)
log.Println(unsafe.Offsetof(b.bflag2)) // 104 (4 + 8 + 92)
log.Println(&quot;b.a2&quot;) // a2 is pointer
log.Println(unsafe.Offsetof(b.a2.flag)) // 0
log.Println(unsafe.Offsetof(b.a2.strs)) // 80 (112)
log.Println(&quot;b.bflag3&quot;)
log.Println(unsafe.Offsetof(b.bflag3)) // 112 (104 + 8)
log.Println(&quot;b.flag&quot;)
log.Println(unsafe.Offsetof(b.flag)) // 116
log.Println(unsafe.Offsetof(b.num)) // 120
log.Println(unsafe.Offsetof(b.ptr)) // 128
log.Println(unsafe.Offsetof(b.mini)) // 132
log.Println(unsafe.Offsetof(b.strs)) // 196
log.Println(&quot;b.bflag4&quot;)
log.Println(unsafe.Offsetof(b.blfag4)) // 208 (112 + 92)
</code></pre>

<p>unsafe.Offsetofは対象の要素を持つ構造体の先頭からのオフセットを指すため、<br />
構造体Bの中にあるAでも、Bからのオフセットではなく、Aの先頭からのオフセットを出力しています。</p>

<p>また、ポインタとして持つ場合、実態は別のところにあるため、a2のサイズはポインタ分のみになります。</p>

<p>構造体を埋め込んだ場合、それらの値がそのままそこに置かれたかのように置かれます。<br />
また、埋め込んだ構造体の値として扱われるらしく、<br />
実態として持っているときと違い、構造体Aの要素でもBの先頭からのオフセットを出力しています。</p>

<h1 id="ソースコード:7df659e690576969cb149167507e359f">ソースコード</h1>

<pre><code class="language-go">package main

import (
  &quot;log&quot;
  &quot;unsafe&quot;
)

type A struct {
  flag bool
  num int64
  ptr *int64
  mini int32
  str string
  nums []int64
  nums5 [5]int64
  strs []string
}

type B struct {
  bflag bool
  intnum int64
  a A
  bflag2 bool
  a2 *A
  bflag3 bool
  A
  blfag4 bool
}

func main() {
  log.Println(&quot;sizeof&quot;)
  a := A{}
  log.Println(unsafe.Sizeof(a)) // 92 (136) 括弧内は64bit
  log.Println(unsafe.Sizeof(a.flag)) // 1
  log.Println(unsafe.Sizeof(a.num)) // 8
  log.Println(unsafe.Sizeof(a.ptr)) // 4 (8)
  log.Println(unsafe.Sizeof(a.mini)) // 4
  log.Println(unsafe.Sizeof(a.str)) // 8 (16)
  log.Println(unsafe.Sizeof(a.nums)) // 12 (24)
  log.Println(unsafe.Sizeof(a.nums5)) // 40
  log.Println(unsafe.Sizeof(a.strs)) // 12 (24)

  a.nums = append(a.nums, 42)
  a.strs = append(a.strs, &quot;デーデッデー&quot;)
  log.Println(unsafe.Sizeof(a.nums)) // 12 (24)
  log.Println(unsafe.Sizeof(a.strs)) // 12 (24)

  log.Println(unsafe.Sizeof(&amp;a)) // 4 (8)

  log.Println(&quot;offest&quot;)
  log.Println(unsafe.Offsetof(a.flag)) // 0
  log.Println(unsafe.Offsetof(a.num)) // 4 (8)
  log.Println(unsafe.Offsetof(a.ptr)) // 12 (16)
  log.Println(unsafe.Offsetof(a.mini)) // 16 (24)
  log.Println(unsafe.Offsetof(a.str)) // 20 (32)
  log.Println(unsafe.Offsetof(a.nums)) // 28 (48)
  log.Println(unsafe.Offsetof(a.nums5)) // 40 (72)
  log.Println(unsafe.Offsetof(a.strs)) // 80 (112)



  log.Println(&quot;b&quot;)
  b := B{
    a2: &amp;A{},
  }
  log.Println(unsafe.Offsetof(b.bflag)) // 0
  log.Println(unsafe.Offsetof(b.intnum)) // 4
  log.Println(&quot;b.a&quot;)
  log.Println(unsafe.Offsetof(b.a.flag)) // 0
  log.Println(unsafe.Offsetof(b.a.strs)) // 80
  log.Println(&quot;b.flag2&quot;)
  log.Println(unsafe.Offsetof(b.bflag2)) // 104 (4 + 8 + 92)
  log.Println(&quot;b.a2&quot;) // a2 is pointer
  log.Println(unsafe.Offsetof(b.a2.flag)) // 0
  log.Println(unsafe.Offsetof(b.a2.strs)) // 80 (112)
  log.Println(&quot;b.bflag3&quot;)
  log.Println(unsafe.Offsetof(b.bflag3)) // 112 (104 + 8)
  log.Println(&quot;b.flag&quot;)
  log.Println(unsafe.Offsetof(b.flag)) // 116
  log.Println(unsafe.Offsetof(b.num)) // 120
  log.Println(unsafe.Offsetof(b.ptr)) // 128
  log.Println(unsafe.Offsetof(b.mini)) // 132
  log.Println(unsafe.Offsetof(b.strs)) // 196
  log.Println(&quot;b.bflag4&quot;)
  log.Println(unsafe.Offsetof(b.blfag4)) // 208 (112 + 92)
}

</code></pre>

                </div>

            </div>

            

<div class="social_buttons">
    
    <span class="twitter">
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="ota42y">Tweet</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    </span>
    

    
    <span class="hatena">
        <a href="http://ota42y.com/blog/2015/05/06/go-struct-offset/" class="hatena-bookmark-button"
           data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="ja"
           title="このエントリーをはてなブックマークに追加">
            <img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png"
                 alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" />
        </a>
        <script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js"
                charset="utf-8" async="async">
        </script>
    </span>
    
</div>

        </div>
    </div>
    <div class="footer_height"></div>


<div class="footer_margin"></div>
<div class="footer_wrapper footer_height">
    <div class="content">
        <div class="footer">
            Copyright © 2015 - ota42y
        </div>
    </div>
</div>
</div>
</body>
</html>

