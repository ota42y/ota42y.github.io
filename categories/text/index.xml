<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Text on おおたの物置</title>
    <link>http://ota42y.com/categories/text/</link>
    <description>Recent content in Text on おおたの物置</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 21 Jun 2015 23:43:02 +0900</lastBuildDate>
    
	<atom:link href="http://ota42y.com/categories/text/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>参加記録 Go Conference 2015 summer</title>
      <link>http://ota42y.com/blog/2015/06/21/gocon-2015-summer/</link>
      <pubDate>Sun, 21 Jun 2015 23:43:02 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/06/21/gocon-2015-summer/</guid>
      <description>今回は日経さんとCAさんがスポンサーとのことですが、
かなりの人がいるのにwifiが普通に繋がっていて凄かったです…
なんか機械も見たことも無い凄い奴でしたし。
実際に運用してる上での話が多く、goの時代が来ている…！
という感じを受けました。
お仕事でほぼ使ってないのでちゃんと使いたいですねー
また、みんなcode generateに走っているのはおもしろかったです。
コピペになるようなコードはgenerateするってのはほぼ統一見解ですね。
キーノート  go1.5凄そうです go oracleのすごさ  関数がどこで使われているかが調べられる 関数ポインタで呼ぶ場合も大丈夫  gomobile、早くiOSに対応してC++を駆逐してほしいです… 公式の依存管理ツールも楽しみです  発表まとめ 発表順は覚えてないので、タイムテーブルに順不同で並べられている順です。
Gaurun〜A general push notification server in Go〜  https://speakerdeck.com/cubicdaiya/a-general-push-notification-server-in-go go製のpushサーバ モニタリング用のAPIを用意してるの、凄い良いなーと思いました。  Debugging Go Code with GDB  http://kaneshin.hateblo.jp/entry/2015/06/21/202850 GDB、あんまり使いこなしてないのでもっとちゃんと使わないと…と思った。 Goはコンパイル早いし、落ちたときにちゃんとどの行で落ちたか出してくれるし、無くても何とかなる感はあります  使った方が何倍も楽なのでちゃんと使った方が良いかと  go 1.5からコンパイラがgoで実装されるけど、吐き出されるバイナリにDWARFが入ってれば関係ないよね？  リリース直後はバグったDWARFになる可能性はありそう…  フォントが$300ってwwwwww  Generative programming in Go.  https://speakerdeck.com/monochromegane/generative-programming-in-go reflection凄く遅いです…(直接呼ぶのと1000倍違う) 金槌を持つと何でも釘に見える病…  gore - Go で REPL のはなし  irbみたいにgoを対話的に実行できるやつの内部事情 go runしてるだけ go runに失敗しないように色々前処理をがんばってるみたいです。  Goと電子工作とロボット  goでロボット制御できて、しかもスタンドアロンで動いていて凄いです  GoのASTをいじくって新しいツールを作る  http://www.</description>
    </item>
    
    <item>
      <title>参加記録 BPStudy#92</title>
      <link>http://ota42y.com/blog/2015/04/29/bpstudy92/</link>
      <pubDate>Wed, 29 Apr 2015 13:49:43 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/04/29/bpstudy92/</guid>
      <description>BPStudy#92に参加しました。
今回は経営やお金の話でした。
お金って資本主義社会のベースとなる概念ですし、
インターネットの仕組みがどうなってるのかとか、
コンピュータがプログラムをどう解釈しているのかと同じぐらい、
お金の事を知っておいた方がいい気がする…と思って参加しました。
エンジニアの経営学  http://www.slideshare.net/bejita/bpstudy92  http://www.slideshare.net/bejita/ss-45051035 一部詳しく書いている別資料  会社は環境の変数にめちゃくちゃ弱い 2014年の倒産件数  9731件 一日あたり26.6社が倒産している これでも前年比10%減  利益は車におけるガソリン  ガソリンが無いと走れない 補給は常に必要 ガソリンの供給源は売り上げのみ  利益＝売り上げーコスト  利益に対するコストの比率が低い、低コストの方が良い コストが低い方が安定する  @ota42y 必要な資金が少なければ少ないほど内部留保が溜まりやすく、変化に対応できるバッファが産まれるからです。ガソリン切れを起こすのが一番やってはいけないことなので、残るものが一緒なら使うカネが少ないほうが安定します。
&amp;mdash; やきう大好きござ先輩 (@gothedistance) 2015, 4月 28  詳しくは二つ目の資料   全ての企業活動はコスト  資料作成、メールを打つ、問い合わせ対応 それ自体は１円も生んでいない。 そのコストを回収するのは売り上げしか無い。 サービス運営で食べていくのは大変 オーダーメイドを作る方が簡単  お金も出してくれやすい  サービス開発は必ず投資が先行する 月額定額は青天井なので嫌われる  組織運営  一人で全ては出来ない 誰かにやってもらわないと組織運営は安定しない 高いスキルを持った人を集めても、ゴミしか生み出せない場合もある Good Player is not Good Manager  チームの将来は決定の速度で決まる  引き延ばしは金と時間の無駄 決定が遅いと間違いに気づくのも遅い 決定の妥当性はいま判断できない Done is Better Than Perfect.</description>
    </item>
    
    <item>
      <title>参加記録 DroidKaigi</title>
      <link>http://ota42y.com/blog/2015/04/26/droidkaigi/</link>
      <pubDate>Sun, 26 Apr 2015 12:49:12 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/04/26/droidkaigi/</guid>
      <description>DroidKaigiに参加してきたのでメモ。
Twitterで流れてくる情報によると、あっちのセッションもおもしろそう…
みたいなのがあったので、ちゃんとセッションの概要も読んで天秤にかけるべきでした。
（エクセルシートから該当のセッションを探すのが大変だったので挫折した）
 Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法 -
 http://www.slideshare.net/yanzm/droid-kaigi2015-yanzm ActivityはFragmentのブセット的な印象。 Fat Activityになりやすい場合はViewとか他の部分にコードを分割しましょうというお話っぽい。  RailsのFat Controller問題?  Fragmentにできる事はそっちにどんどん任せて、ActivityはActivityにしか出来ない部分に集中しようってこと？ Activityにしか出来ないことが多すぎるからFat Activity問題になってたので、 似たようなことが出来るけどライフサイクルをコントロールできるクラスの登場によって、 処理の分割ができるようになった感じ？  開発を効率的に進めるられるまでの道程
 http://www.slideshare.net/TakaoSumitomo/ss-47393000 コードを書くのとテストを書くのが一番開発で大変なところ どんな風にテストしているかの事例紹介  ダミーを作ってがんばる感じ 複数の間を取り持つクラスは疎通確認のみ   あるゲームアプリケーションの構成とアップデートサイクル
 http://www.slideshare.net/kentaroiizuka/droidkaigi 様々なリソースから、バイナリやアップデータを作るまでをすべてJenkinsがやっている  専用のパイプラインエンジニアがいるらしい  Playgroundつよい  Cocosはお察しなできなので… (´・ω・｀)  Luaでゲーム部分を書く  ゲーム部分以外はフレームワークが吸収  リソースの追加ダウンロードとかもフレームワーク側が持っているらしい  ゲーム側はゲームとしての実装に専念できるっぽい
   Android学ぶを君へ。生き抜くためのナレッジ共有
 https://github.com/operando/DroidKaigi 有用な情報がたくさん adbが思っていた以上に優秀だった  任意のアプリのViewTreeが見られるらしい  テスト書こう 発表と関連する資料が全部まとまっているの凄い便利  Kotlin</description>
    </item>
    
    <item>
      <title>参加記録 第四回　ゲームサーバ勉強会</title>
      <link>http://ota42y.com/blog/2015/04/19/game-server-4/</link>
      <pubDate>Sun, 19 Apr 2015 11:03:24 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/04/19/game-server-4/</guid>
      <description>第四回　ゲームサーバ勉強会に参加しました。
サーバにはあんまり詳しくないですが、そういう人向けの勉強会なので助かりました。
特に名前は聞いたことがあるけど使ったことないorちょっと触ったぐらいの物の理解がある程度深まりました。
IDC Frontierさんの話  IDCクラウドの話
 http://www.idcf.jp/cloud/ 最小プランが500円からとのこと…安い  ゲームでも採用事例あり。
 http://gihyo.jp/admin/column/01/vm/2014/nanohain02 http://ascii.jp/elem/000/000/952/952870/   ゲームサーバの作り方  http://www.slideshare.net/honyax/ss-47136625 簡単なチャットサーバの作り方 ゲームサーバも基本的なメッセージやりとり部分はチャットサーバみたいな物。  fluentdとembulkの話  http://www.slideshare.net/repeatedly/fluentd-and-embulk-game-server-4 外部からはjsonで入力するが、内部はMessagePackらしい tg-agentはfluentdにRubyインタプリタやプラグインをまとめてセットアップしやすくしたもの とりあえずfluentdに送って、そこから適切な場所に割り振る使い方みたい 組み込み環境向け  https://github.com/fluent/fluent-bit  Windows環境で動くやつ  https://github.com/fluent/fluentd-forwarder 名前の通り、ログをfluentdに転送するものっぽい？ これ本体で分類とかはせず、転送先のfluentdで転送する用途？  embulk  https://github.com/embulk/embulk ファイルから一気にデータを入れる用 失敗時に必要なファイルだけ再処理できる データから形式を推測する機能もある  fluentd-ui  https://github.com/fluent/fluentd-ui fluentdのWebUI データ処理のための正規表現をテストできる機能がある  データ欠損  ストリーム処理はデータ欠損が出てしまうもの 欠損が許されないものに使うのは危険  課金ログとか  欠損率0%の人もいるらしい  構成による？  通信失敗とかはfluentdが検知するのでそれで欠損はしない   負荷がたかいいんだから～♪（仮）  ゲームの負荷対策と負荷試験の話 memcached  全部メモリに乗ってるKVS  レプリケーション遅延  (たぶん)masterへの変更がslaveに変更される前に読み込んでデータがおかしくなった 水平分割して対処  特定のIDは特定のDBに書き込むようにする 1台あたりのリクエスト数を減らす？   NoSQL  Cassandra  リング型ノードになるため単一障害点がなくなるらしい DHT？  トランザクション処理は基本弱い  そういうところはMySQLで   負荷試験  リリース前に想定人数をちゃんと裁けるかのテスト  リリースしてから落ちにくい チューニングしやすい  テーブル構造の変更とかしやすい    JMeter  http://jmeter.</description>
    </item>
    
    <item>
      <title>参加記録 GolangNotHttpNight（Gunosy.go#12）</title>
      <link>http://ota42y.com/blog/2015/04/14/golang-no-http-night/</link>
      <pubDate>Tue, 14 Apr 2015 22:39:40 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/04/14/golang-no-http-night/</guid>
      <description>GolangNotHttpNight（Gunosy.go#12）
に参加しました。
ほぼ周りにgolangを使っている人がほとんどおらず、
情報がほぼ入ってこない環境にいるため、
ためになる話ばかりで、とても有意義な時間でした。
gomaについて  https://speakerdeck.com/kyokomi/gomanituite https://github.com/kyokomi/goma  Domaインスパイア  DBのテーブルから対応する構造体とCRUD用の関数を作ってくれるみたい DBへのアクセスは書き出されたSQLファイルを使う  SQLはgo-bindataでバイナリに入れ込む  いくつかライブラリを利用するが、作成されるコードには含まれないらしい  テーブル情報を取得するためにxormを利用 SQLファイル書き出しのためにegoを利用 CLI用にcliを利用   golintを使おう  いろいろ細かい所までチェックしてくれるgolintの話 pre-commitで実行するといい よくわかってなかったのでちゃんと使おう  go-timeout、もしくはUnixツールをgolangで書く話  http://songmu.github.io/slides/gunosygo-12/#0 mackerel-agentはgo製  https://github.com/mackerelio/mackerel-agent サーバ監視用の情報をmackarelに送る  https://mackerel.io/  pluginで拡張できる  外部コマンドとして呼んでるだけ   pluginが無限ループしたりするとブロックしてしまう  一定時間後にKILLするようにした  timeoutコマンドのようなものをgoで実装    Golang+Raspiで趣味的IoT入門的な話  https://speakerdeck.com/ymatsuwitter/golang-plus-raspidequ-wei-de-iotru-men-de-nahua Raspberry PiでIoT  armなのでgoでクロスコンパイル可能  Gobot  http://gobot.io/ いろんなデバイスをかなり抽象化された形で利用できる ロボットにパーツをつけていくメタファ 対応していないと使えないけど、対応しているととても便利っぽい  embed  https://github.</description>
    </item>
    
    <item>
      <title>参加記録 第6回ニコニコ学会β　データ研究会</title>
      <link>http://ota42y.com/blog/2015/04/12/niconico_data_6/</link>
      <pubDate>Sun, 12 Apr 2015 21:03:35 +0900</pubDate>
      
      <guid>http://ota42y.com/blog/2015/04/12/niconico_data_6/</guid>
      <description>第6回ニコニコ学会β　データ研究会に参加しました。
基調講演  日立のH  スペシャリストのデータに基づいた施策より、超詳細なデータから計算した施策の方が有効  http://web-tan.forum.impressrd.jp/e/2015/03/06/19423  人間では見つけられない要因を特定できる  スキルより休憩中の雑談の盛り上がりが重要だったり 膨大なデータの因果関係を調べ上げるのは人間には無理   ウェアラブルハピネスメーター  人は動き続けているほど止まらなくなる  T時間動き続けると、止まる確率が1/T  実際のデータと1/Tとの乖離が高くなると、集団の幸福度が低下する  1/Tに近いほど集団が幸福度が高くなる  幸福度と業務の生産性は直結する  1/Tを上げることが生産性を上げることになる 生産性や幸福度に関連するデータを短いスパンで計測することができる  日々のKPIとして利用できそうなところが革新的っぽい 日立、集団の幸福感を測定する技術を開発 - PC Watch    参考  データの見えざる手: ウエアラブルセンサが明かす人間・組織・社会の法則  後で買う    人狼知能  脱初心者！経験は人狼力を向上させるのか？～データから見るベテランの実力～  http://www.slideshare.net/toritorix/ss-46899953 人狼BBSの分析 陣営ごとの平均プレイ回数が多い方が勝率が高い  運ゲーじゃなかった  経験によるスキル向上  占い師  的中率は変化なし  狩人  上級者ほど護衛成功しやすい  人狼への投票率  ちょっとだけ高い 上級者が複数人の陣営はわりと高くなる  個人の経験より集団の経験の方が強い  人狼知能プロジェクト  人狼BBSのデータセットとか公開するらしい http://www.</description>
    </item>
    
    <item>
      <title>Evernoteのリンクをアプリで開くChrome拡張を更新した</title>
      <link>http://ota42y.com/blog/2015/01/31/evernote-opener-update/</link>
      <pubDate>Sat, 31 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/31/evernote-opener-update/</guid>
      <description>evernote url openerを更新しました。
使うためには、EvernoteのユーザIDとShardを調べる必要がありますが、
ちょっと面倒だったので、ユーザが自分のノートリンクをペーストするだけで、設定するように変更しました。
Evernoteからコピーできる、
https://www.evernote.com/shard/USER_SHARD//WORD/USER_ID/NODE_ID/
といった形式のリンクを張ることで、USER_SHARDとUSER_IDを保存します。</description>
    </item>
    
    <item>
      <title>参加記録 情報科学若手の会冬の陣2015</title>
      <link>http://ota42y.com/blog/2015/01/25/wakate2015w/</link>
      <pubDate>Sun, 25 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/25/wakate2015w/</guid>
      <description>情報科学若手の会冬の陣2015 #wakate2015wに参加しました
Togetterまとめ
会場は電源完備＆大きめの机が椅子に着いているという豪華仕様でした
まとめ  黒崎優太 (@kuro_m88) ICTトラブルシューティングコンテストの紹介
 http://icttoracon.net/ ネットワーク版CTFみたいなコンテスト Ciscoがスポンサーについているので、高価な機材がいっぱい用意されるみたい 大きな規模のネットワークであれこれするのって普通じゃ出来ないし、面白そうです。  浅野智之 (@asanon_s) Webの世界に散らばるデータをつなぐ技術
 semantic webやPDFの話 人間が読めれば良い形式から、構造化されて機械も読める形式を加えるみたい なんとなく理解が深まった気がします 完全なsemantic webへの道のりはまだまだ  門脇香子 証明プログラミング入門
 http://www.slideshare.net/ussopyon/ss-43846794 OpenSSLの脆弱性をCoqで見つけた話を聞いてから、証明プログラミング凄そうだけどよくわからない状態だったので、 理解が深まりました。 何を証明すれば良いかを補完してくれるのは便利そうでした  佐野岳人 コードを書けば複素数が分かる
 http://www.slideshare.net/taketo1024/ss-43853048 初めて複素数が何なのかを感覚的に理解できた気がする… デモで関数をインタラクティブに可視化しているのが本当に凄かった ここから使える https://github.com/taketo1024/SwiftComplex  辻順平 (@tsujimotter) 日曜数学のススメ
 http://www.slideshare.net/junpeitsuji/2015-43856733 コンパスと定規で作図可能かどうかを判定するガウスの判定法凄い 折り紙だと四次方程式が解けるので、作図できなくても折れる場合があるとか凄い  池尻良平 ニュースと類似した歴史を求めるアルゴリズムを考えてみた – 役に立つ歴史教育を目指して
 現代のニュースと、それに類似する歴史上の出来事を提示するシステムを作っているそうです 過去にどんな解決策をとって、どういう結果になったかを考えるのにとても便利そうです 早く使ってみたいですね  後藤紳 モバイルデータを用いた行動予測
 あんまり書いちゃいけなさそうなので割愛 GPSの行動ログを蓄積して、次に何をしそうか提示するみたいです 同じような日々を送っている人には効果的っぽいです  宮代理弘 (@3846masa) Processin.</description>
    </item>
    
    <item>
      <title>参加記録 Jenkins ユーザ・カンファレンス 2015 東京</title>
      <link>http://ota42y.com/blog/2015/01/11/jenkins-conference/</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/11/jenkins-conference/</guid>
      <description>Jenkins ユーザ・カンファレンス 2015 東京に参加しました。
Togetterまとめ
発表まとめ アンケート結果  参加申し込み時のアンケート結果 多くの人のjobの数が1〜数個程度 Jenkins無くても生きていける人が30％ぐらい
 思ったよりもみんなJenkinsを使い込んでいない印象 アンケート結果は後日公開  Jenkinsプロジェクトの現状とワークフロー  DotCiが良さそう  https://github.com/groupon/DotCi Jenkinsを他のCIサービスみたいにする Github限定 設定をYAMLファイルで管理出来たりする  Workflow Pluginすごい  Build Flow Pluginをいっそう強化した版 ビルドが失敗しても途中から再開とかも出来る 乗り換えよう ただ、DSLを覚えたりと学習コストが高くなるので秘伝のタレ化の危険が   JenkinsとSeleniumの活用事例：試験自動化のプロジェクトへの導入  アジャイル開発だとイテレーション毎に試験項目は増えていくが、開発後半になるほど試験に割ける時間は減る  あるあるすぎる 試験自動化で試験項目の消化にかかるコストを下げる  スクリーンショットを撮って画像比較して変更検知  静的な画面なら効果的っぽい アニメーションする場合は撮るタイミングによりそうなので、目で比較かなぁ…  テストケースの保守大変そう  ちょっと変わっただけで使えなくなるし   Jenkinsを使ったコンシューマゲームでのデプロイとテスト  http://www.slideshare.net/swiftnest/jenkins-43394510 圧縮して6GB、11万ファイルのプロジェクト  2プラットフォーム2言語にビルド これで中規模ぐらいと凄い世界が…  FFとかどんだけなんだろう…   フルビルドに14時間かかる  リソースの事前処理に時間がかかる  リソース内での分岐処理が遅いため、全条件分のリソースを作る  データを実機上でビルドする必要がある  携帯機は貧弱なので差分ビルドでも4時間かかったりする プラットフォームで互換性なし PS3はビッグエンディアン VITAはリトルエンディアン  ファイルをパックするのでキャッシュが効かない  ファイルアクセス回数を減らすため必須 全データを実機でパックするため6時間ぐらい   頑張って並列化して5〜9時間ぐらいまで減らす  データの処理を4台で並列化  一台4時間ぐらいに短縮   テスト  テストフレームワークなど無い スモークテスト  特定ミッションに入れるかどうかをテスト 引数で専用のミッションを始められるように  一定時間たったら終了させる 正常終了しなかったらエラー  起動からスタート、終了までがちゃんと動くか リソースに問題ないか エフェクト再生チェック 一定時間内に終わるか データが変換可能か  モンキーテスト  開始からエンディングまでの通しプレイAI 良い感じに攻撃する  適当にボタン連打  適当に移動 何回もゲームオーバーになったら無敵＆攻撃力１００倍 メニュー操作テスト 普通のUIテストっぽい 長時間テスト特有のバグ発見に繋がる リソースの解放漏れ  携帯機はスリープできるので普通は電源を切らない   問題点  作成やメンテナンスにコストがかかる ゆとりがある時期にどれだけ作れるか勝負 チェックに時間かかる 一日じゃ終わらない 手動テストの置き換えにはならない テストのパターンが固定化されるため、外れた部分のバグは検知不可 人の手のかかるテストを減らす効果    おばかXFDコンテスト  人は慣れる生き物  何度も通知してるとそのうち無視するようになる  エラーメールを迷惑フォルダに入れたり パトランプの上に被せたり  XFDによる通知で、慣れに逆らう   LT大会  Jenkinsを使った継続的Webセキュリティテスト  継続的にセキュリティテストを実施するVAddyの話  http://vaddy.</description>
    </item>
    
    <item>
      <title>UNIXという考え方という本を読んだ</title>
      <link>http://ota42y.com/blog/2015/01/04/unix-boox/</link>
      <pubDate>Sun, 04 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/04/unix-boox/</guid>
      <description>UNIXという考え方という本を読みました。
原著は1994年に書かれている本で、 UNIXの哲学を一つ一つ、その意味と利点について解説しています。
「一つのことを、うまくやれ」や「小さいものは美しい」等、ある程度ハッカー文化に詳しい人ならばどれかは聞いたことがあるぐらい有名な哲学です。
面白いのは、例えば「できるだけ早く試作を作成する」という項目では、設計を完璧にしてから取りかかるのではなく、 プロトタイプを作り、それをユーザに見せてフィードバックをもらい、良い設計にしていくべきと述べられています。
これはアジャイル開発のイテレーションを回していく手法ととても似ており、開発手法の歴史を感じます。
また、「一つのことを、うまくやれ」は色々やる巨大な関数より、ちゃんと機能毎に分割しろと解釈できますし、「ソフトウェアの挺子（てこ）を有効に活用する」は他のいいプログラムからコードを借りてきたり、gemやnpmで既にあるソフトウェアを利用するといった、コードの再利用性の話だと解釈できます。
原著は1994年に書かれたにもかかわらず、今日でも普通に通用する哲学がちりばめられており、UNIX哲学の現代のプログラミング文化への強い影響と、その普遍性をかんじます。
ただ、本書の中でシェルスクリプトが移植性もいいし簡潔に書けるしと礼賛されていますが、デバッグしにくい上に、コマンドがGNUかBSDかで結果が変わる場合があるので実は移植性がそんなに無いですし、現代ではちょっとどうなのかな…みたいな部分もあります。
今ですと、スクリプト言語かクロスコンパイルが簡単にできるGo言語が良い選択肢でしょうか。
そういった具体的な部分に関しては時代の変化で合わなくなっている部分もありますが、その哲学自体は普遍的なもので、今読んでも、おそらくは10年後に読んでも得るものが多い本だと思います。</description>
    </item>
    
    <item>
      <title>大晦日ハッカソン2014&amp;正月ハッカソン2015に参加した</title>
      <link>http://ota42y.com/blog/2015/01/01/1231-hackathon/</link>
      <pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2015/01/01/1231-hackathon/</guid>
      <description>2014/12/31にオンラインで行われた、
大晦日ハッカソン2014に参加しました。
Evernoteのリンクをアプリで直接開くChrome拡張を作りました。
evernote app opener - Chrome ウェブストア
(なお、細かい修正やこの記事の執筆等を、
正月ハッカソン2015でやりました)
どんなChrome拡張か 現在、Evernoteのノート固有のリンクを取得すると、
https://www.evernote.com/shard/文字列/文字列/ユーザID/ノートID/
といった、httpsのリンクが使われます。
このリンクを開くと、EvernoteのWebアプリ上でノートを開くことが出来ますが、
Evernoteはログインが最長で一週間しか保てず、また二段階認証をしている場合は、
頻繁に面倒なログインを求められます。
ですが多くの場合、開こうとしているノートはオフラインのEvernoteアプリでも開くことが出来ます。
そのため、Webではなくアプリで開く事が出来れば、わざわざログインせずともノートを開くことが出来ます。
そのため、上記のようなWebアプリでノートを開くようなリンクを、
オフラインのEvernoteアプリ上で同じノートを開くChrome拡張を作りました。
使い方 事前に、適当なノートのノートリンクを取得し、自分のユーザIDとshard名を取得する必要があります。
Chrome拡張のオプションページにあるように、ノートを右クリックし、ノートリンクを取得し、
そのURLに含まれているユーザIDとshard名をオプションページで設定してください。
その状態で、Evernoteのノートリンクを開くと、ログイン/非ログインに関わらず、
Evernoteアプリが立ち上がり、そのノートを開いてくれます。
これで、いちいちWebでログインすることなく、ノートリンクで指定したノートを表示することが出来ます。</description>
    </item>
    
    <item>
      <title>GithubのContributionsを使ってアウトプットを150日続ける</title>
      <link>http://ota42y.com/blog/2014/12/31/150-output/</link>
      <pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/12/31/150-output/</guid>
      <description>というわけで、GithubのContributionsを利用して、
毎日何かしらのアウトプットを150日続けるということをやりました。
何故こんな事をしたのか 私はまじめ系クズな上に意志薄弱なので、やった方がいいようなことでも、
いろんな理由をつけてやらないのがいつものことでした。
特にインプットに重きを置く性質のため、いろいろなことを調べたりしますが、
アウトプットは何かしらの理由をつけて避けてしまう傾向があります。
実際、このブログにしたのは2013年9月ですが、そこから半年で1エントリのみ、
その後の3ヶ月も月に1回程度とほとんど書いてないに等しいです。
別にそのままでも問題は無かったのですが、せっかく色々インプットしているのに、
定着させないのはもったいないと思い、継続的にアウトプットする方法を模索しました。
継続的なアウトプットをどう実現するか 毎日継続的アウトプットを頑張る！と奮起しても、それが継続しないのが今回の問題です。
そのため、頑張る/頑張らないといった意思に関係なく続けられる、
もしくは歯磨きをせずに寝ようとした時のように、
継続してアウトプットしないと落ち着かないといった状態を目指します。
幸いにも、私の性格には続けたことを辞めるのを凄くもったいなく感じるというものがありました。
大学時代には、一日一冊づつ本を読んでいて、たまたま数十日続けたところで辞めるのがもったいなくなり、
結局1000日ぐらい毎日本を読み続ける、みたいな事をするぐらいには、
ある程度続いたものを途中で辞めるのを嫌う性格です。
この性質を利用し、最初のアウトプットを頑張って続けている状態から、
低いコストで継続してアウトプットを続けられれば、以降はそれを途中でやめるのがもったいなくなり、
継続的なアウトプットが出来るのではないか？と考えました。
おそらくは数日かけてじっくり練ったアウトプットよりかは質が落ちますが、
ほとんど出ない質のいいアウトプットより、継続的に低い質のアウトプットをした方が、
私にとっては良い影響になると考えました。
ルール設定 数日程度なら意思の力で何とかなるため、それを低コストで継続的に行いやすく、
かつ続けるうちに辞めるのが勿体ないようなルール設定を作ります。
1. アウトプットは外部に公開 自分だけにしか見えないところにアウトプットすると、
結局なんだかんだでやらない未来が容易に想像できるため、必ず外部公開します。
今回みたいに定期的に続けてますエントリを書くことで、万が一検証されたら嘘がばれる…という力が働き、
サボったのをごまかすことがなくなると考えました。
(検証されるかは重要ではなく、検証される可能性があるだけでサボり抑止には十分)
2. １日１コミット以上Githubにpush 毎日続けた事を記録するのはとてもとても面倒です。
ですが、Githubなら最初の画像のように、コミットがあった場合にそれを可視化して表示してくれます。
そのため、アウトプットをコミットすることでGithubにpushするだけで良くなり、
前述の外部公開するという条件も同時に満たせるためかなり敷居が下がります。
特に、プログラミング関係の作業がそのまま記録できたり、ブログをOctopressにしているため、
新しいエントリを書くのもコミットになっているという所も大きいです。
3. コミットを溜めるのは可 風邪を引いたり、仕事が忙しいときなどはどうしても何も出来ない場合があります。
そんな場合に、事前にブログの記事やコミット等を溜めておき、当日は公開するだけというのもありとしました。
今回の最大の目的は継続的なアウトプットであり、
毎日アウトプットするのは私の性格を利用して継続的アウトプットを成し遂げるための手段に過ぎません。
そのため、継続的なアウトプットが実現するならば、事前にそれを溜めておくのは良しとしました。
特にこの方法は途中で辞めるのがもったいないと感じるという所を利用して、継続的アウトプットを実現しているため、
一度でもそれが崩れると挽回は不可能であるためです。
また、私はゲームでもHPやアイテム、リソースを十分すぎるほどため込むのが好きな正確なため、
何日分の溜めがあると可視化されると、十分な量の溜めを確保しようと動くだろうという予想もしていました。
gitだと別の日のコミットも、git rebase &amp;ndash;ignore-dateでそのときのコミットに書き換えられるため、
溜めを作りやすい状態でもあります。
4. 意味のあるコミットだけカウント Githubだとpull-requestをマージするだけで1コミットが作られるため、ボタンを押すだけで1日分稼げてしまいます。
ですが、これは当初の継続的なアウトプットには繋がらないため、
最低限意味のあるコミットを行うのをルールとしました。
ただし、今回の目的は定期的なアウトプットであるため、アウトプットの質自体は考慮せず、
どんなに小さくてもバグ修正や、関数単位では出来ているものは1コミットとして考えるようにしました。
無意味なコミットは禁止するが、あまり価値のないコミットでも許可するといった具合です。
150日続けた結果 利点 誰かが「何かをやめる最良の方法は、別の何かを始めることだ」と言っていましたが、まさにそれを感じでいます。</description>
    </item>
    
    <item>
      <title>pixivのタグから読み解くラブライブイラスト投稿者分析</title>
      <link>http://ota42y.com/blog/2014/12/27/lovelive-age/</link>
      <pubDate>Sat, 27 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/12/27/lovelive-age/</guid>
      <description> この記事は2014年版で、2015年をまとめた版があります
(2015年のpixiv内ラブライブイラストの推移)
昨日、一昨日とラブライブイラストについて見ていきましたが、
最後にイラストを投稿している投稿者さんについて見ていきます。
投稿者の性別傾向 集計方法 キャラのイラストと、ラブライブ関連イラストを投稿した人全員に対して、性別と年齢を調べてまとめました。
なお、各データはユーザページで公開されているものを利用したため、
全体に情報を公開している人のみの集計になります。
各キャラ毎の性別傾向 各キャラ毎に、男性と女生徒でどれくらいの割合で投稿しているかを集計しました。
なお、キャラ毎に投稿数ユーザ数がそもそも違うため、
そのキャラに投稿した人のうち性別が判別できるユーザがどれくらいの割合なのかを集計しています。

ラブライブタグ全体では女性投稿者の方が多い結果になりました。
キャラ毎では、男性投稿者が多いキャラが５人に、女性投稿者が多いキャラ人気が４人と、
μ&amp;rsquo;sメンバーの中でも男女のユーザ数が半分に別れています。
特に男性からの投稿が多いのは高坂穂乃果、園田海未の二名です。
女性からの投稿が特に多いのは、南ことり、矢澤にこの二名になります。
また、星空凛は男女共にほぼ同数の投稿人数になります。
なお、昨日の記事でも紹介した、閲覧数の多いカップリングである、
「にこまき」「のぞえり」「ことうみ」「りんぱな」ですが、
カップリングの片方ずつで男性投稿者と女性投稿者の投稿数が割れています。
男性女性、それぞれから支持を得るキャラ同士のカップリングだから人気だったりするのでしょうか？
カップリング毎の性別傾向 前回の記事で集計した総閲覧数1,000,000以上のカップリングに対して、
性別ごとに投稿者の割合を集計しました。

人気のカップリングでは女性投稿者が多いことがわかります。
また、キャラごとの傾向では片方が6割を超えることはありませんでしたが、
カップリングごとでは6割超えが多く見られ、かなり偏りがあります。
なお、キャラ別に比べて有効なユーザ数が少ないため、
必ずしも正確な調査ではない部分にご注意ください。
ラブライブ投稿者の年齢層 集計方法 ラブライブのイラストを投稿した全ユーザから、年齢を公開しているユーザを集計しました。
各キャラ毎に年齢別にユーザ数を出していましたが、
ほぼ全キャラ同じ傾向になったため、ラブライブイラスト全体で出すことにします。
集計結果 有効なデータ数は男性3665、女性2771、性別不明765の7201件でした。
なお、10才から5才区切りで集計しています。

20〜25才未満が最も投稿している結果になりました。
そこから+-5才が二番目に多いすが、25才以上は男性がほとんどなのに対し、
20才未満は女性が多くを占めています。
そのため、20代男性と、15〜25才の女性投稿者が多いようです。
まとめ  ラブライブイラスト全体では女性投稿者の方が多い  キャラ毎では、男性の投稿者に人気、女性の投稿者に人気がわかれている 人気の4カップリングは、男性人気+女性人気の組み合わせキャラだった  カップリングイラスト投稿者は女性投稿者の方が多い  投稿者の男女別人気も、キャラのそれよりも偏りが大きい  投稿者は男女で若干世代が違う  女性は15〜25才、男性は20〜30才  最も投稿が多いユーザは一人で250件以上投稿していた  そのほぼ半分に西木野真姫タグがついており、同キャラの最多投稿ユーザ   </description>
    </item>
    
    <item>
      <title>pixivのタグから読み解くラブライブカップリング傾向(2014年11月現在)</title>
      <link>http://ota42y.com/blog/2014/12/26/lovelive-cp/</link>
      <pubDate>Fri, 26 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/12/26/lovelive-cp/</guid>
      <description>この記事は2014年版で、2015年をまとめた版があります
(2015年のpixiv内ラブライブイラストの推移)
昨日はラブライブタグ全体と、各キャラについて見ていきましたが、
今日はカップリングについて見ていきます。
なお、既に調べられていたので、半分ぐらいはその内容のアップデートになります。
pixiv のタグ情報を用いた「ラブライブ！ School idol project」のカップリングネットワークの構築
収集方法 pixivのタグから、各カップリングタグ（「にこまき」、「のぞえり」等）とラブライブタグがついているものを収集し、 そのイラストの閲覧数の和を集計しました。
条件にラブライブタグを含めないと、高坂雪穂と星空凛の「ゆきりん」タグで別のゆきりんが引っかかる等、
ラブライブとは関係のないものも含まれてしまうため、このような条件にしています。
また、「まきりんぱな」や「ことほのうみ」といった３人を含むタグについては、
「まきりん」と「りんぱな」として集計することはせず、結果から除外しています。
なお、元となったエントリの詳しい収集方法がわからないため、
単純な数値比較は出来ませんのでご注意ください。
順番を加味しない場合 「にこまき」と「まきにこ」を同一視する場合です。
収集結果 (クリックで大きく見られます)

にこまきの人気は相変わらず圧倒的です 時点がのぞえりなのも前回から変わりません。
ですが、３番目のことうみが、前回よりも他を大きく引き離してきています。
また、つばほのがマイナーカップリングを凌ぐほどの人気になっていたり、
ゆきありが地味に伸びていたりと、メインキャラ以外の部分にも多少変化があります。
グラフ 1,000,000以上のみ 元記事に習い、1,000,000未満の辺がﾐﾄﾒﾗﾚﾅｲ場合、組み合わせはこのようなグラフになります。

前回は生徒会グループと、広義の一年生グループとに別れていましたが、
ほのまきとのぞにこの人気が上がったことにより、全てが繋がりました。
また、高坂穂乃果は4種類のカップリングがあり、最もカップリングの種類が多いキャラになっています。
100,000以上のみ 100,000未満の辺がﾐﾄﾒﾗﾚﾅｲ場合は以下のようなグラフになります。

西木野真姫、絢瀬絵里、高坂穂乃果に線が集中し、りんぱなにはそれほど線がありません。
また、高坂雪穂と絢瀬亜里沙はどちらも実の姉とは繋がっていないのがわかります。
最もカップリングが多いのは、μ&amp;rsquo;sメンバー全員と繋がっている西木野真姫と、
8人＋綺羅ツバサと繋がっている高坂穂乃果になります。
順番を加味する場合 「にこまき」と「まきにこ」を別物として数えます。
集計結果 行＋列のカップリングスコアになります。
(クリックで大きく見られます)

複数のイラストを含んだ投稿などで、「のぞえり」と「えりのぞ」が両方つけられるような場合があり、
前述の順番を加味しない場合と、順番を加味した場合の和は異なっています。
基本的には「のぞにこ」と「ほのまき」が増えた以外は前の結果とほぼ変わりませんでした。
なお、前回の結果と比べて「まきりん」が減少していますが、
不審に思って調べたところ、「まきりん」タグ自体の登録数は少なく、
そもそも前回の結果のような大きい値になることは考えにくいです。
一方で、タグを完全一致ではなく部分一致にし、「まきりん」の集計に「まきりんぱな」も入れると、
似たような大きな値になるため、おそらくはこれが原因だと思われます。
グラフ 1,000,000未満の辺がﾐﾄﾒﾗﾚﾅｲ場合、グラフは以下のようになります。

南ことり、星空凛は常に先に来ているのに対し、西木野真姫、園田海未は誰が相手でも常に後に来ています。
また、「のぞえり」と「えりのぞ」だけがお互いに辺を作っています。
一番人気の「にこまき」の方向がほぼ固定なのと比較すると、かなり特徴的です。
なお、これ以下の閾値やR-18作品の結果などは前回と大きな変化が見られなかったため、省略します。
カップリングイラスト投稿数推移 カップリングは全部で72通りあるため、投稿数1,000,000以上のカップリングのアニメ化後の推移をまとめました。
なお、月ごとの投稿数で調べたところあまりにも乱高下が激しく、わかりづらいグラフだったため、
月ごとの累計投稿数で集計を行いました。
投稿数1,000,000以上 一期放映直後から、にこまきの投稿数が圧倒的であることがわかります。</description>
    </item>
    
    <item>
      <title>pixivのタグから読み解くラブライブイラストの歩み</title>
      <link>http://ota42y.com/blog/2014/12/25/lovelive/</link>
      <pubDate>Thu, 25 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/12/25/lovelive/</guid>
      <description>この記事は2014年版で、2015年をまとめた版があります
(2015年のpixiv内ラブライブイラストの推移)
⊂(・8・)⊃＜776O776J7722776B772s772n772n772n776dIQ==
さて、ラブライブ！ Advent Calendar 2014最終日は、
pixiv上のラブライブのイラストについて見ていこうと思います。
内容としては以下になります。
 pixiv上のラブライブイラストの推移(本記事) pixivのタグから読み解くラブライブカップリング傾向 pixivのタグから読み解くラブライブイラスト投稿者分析  なお、一つの記事にするには長すぎたため、
3記事に分割しています。
今日はpixiv上のラブライブイラストの推移について書いていきます。
集計方法 各キャラ毎のイラストに関しては、そのキャラの本名、
もしくは別名+ラブライブタグがついたイラストを集計しています。
(ことりちゃんや凛ちゃん、のんたん等、ラブライブ以外の同名タグを含めないため)
ラブライブ！タグとしては、ラブライブ！およびLoveLive!といった作品名のタグのついたイラストと、
各登場人物のイラストを重複排除して集計しました。
（ラブライブ！タグのついてないキャラのイラストもあるため）
集計期間は、ラブライブイラストが初めて投稿された2010年8月〜2014年11月になります。
年間イラスト数の推移 
一期放送の2013年に投稿数が増えた後、二期放送の2014年でさらに4倍近くイラスト数が伸びています。
ご覧の通り、アニメ化以前と以後とでは、投稿数が100倍ぐらい差があるため、
ここから先はアニメ化以前とアニメ化以後、およびキャラ毎の3種類に分けて見ていきます。
アニメ化以前の月刊イラスト投稿数 
各シングル発売のたびにイラストが増加しています。
1stシングル発売後は一度投稿数が落ち込みましたが、
2ndシングル「Snow halation」が発売してからは安定した投稿数を確保しています。
その後も、3rd、4thと着実に投稿数が伸びています。
4thシングル&amp;amp;1stライブ&amp;amp;アニメ化発表の時の盛り上がりが凄いですが、
同時に3月まで5thシングルの総選挙があったため、3月の投票数も伸びています。
なお、この月の誕生日の園田海未を除くと、
南ことり、矢澤にこ、西木野真姫の3人が他のキャラと比べて増加していましたが、
総選挙の上位三人になっており、データ数が少ないので偶然かもしれませんが、ちゃんと対応が取れていました。
ちなみに、5thシングル前の7月にも山が見られますが、調べたところにこの聖誕祭効果でした。
アニメ化以降の月刊イラスト投稿数 
アニメ化以前は月間投稿数が100を超えることはありませんでしたが、
アニメ化以降一気に投稿数が伸び、放送終了後以降は月刊投稿数が1000を切ることがないぐらいにまで成長しました。
投稿数の増加は夏コミまで続きますが、夏コミ(C84)が終わった後はいったん沈静化します。
ですが、12月の冬コミ(C85)と3rdのDVD/BD発売から再び火がつき、
2月のライブにかけて再びイラスト数が増加していきます。
特に、ライブ直後の二週間だけで投稿数が2000を超すなど、二期を直前にして盛り上がりは最高潮に達しています。
二期が放映されてからは一期以上のペースで伸びていき、
一期と同じく夏コミ(C86)まで増加して一度沈静化しました。
今月は冬コミ(C87)が控えているため、おそらくそれによってまた増加すると思われます。
学年ごとの集計 一週間筒キャラ毎にまとめたのを用意したので、もう少し細かく見ていくことにします。
なお、各キャラ共に誕生日とその次の日にかけて、聖誕祭イラストとして投稿数が増加します。
そのため、キャラの誕生日と次の日を別の週として集計すると、実態と集計結果がずれてしまいます。
幸いなことに、投稿数が増えた2013年〜2014年の間で水曜日が誕生日のキャラはいないため、
木曜〜水曜の一週間で集計し、誕生日と次の日が分割されることを回避しています。
1年生 
これは全てのキャラに言えることですが、各キャラの誕生日ごとにスパイクが発生し、
イラスト数が増加しているのがわかります。
また、こちらも各キャラ共通ですが、4thライブ直後にもイラスト数が増加しています。
キャラとしては、アニメ化前からちょくちょく人気でしたが、やはり西木野真姫の投稿数は安定しています。
また、2013年はイラスト数が少なかったため、矢澤にこの聖誕祭でにこまきカップリングとして、
投稿数が伸びていました。 なお、2014年はイラスト数が増えたため、相対的に影響が小さくなっています。</description>
    </item>
    
    <item>
      <title>参加記録 Android Bazaar and Conference 2014 Winter</title>
      <link>http://ota42y.com/blog/2014/12/21/abc2014w/</link>
      <pubDate>Sun, 21 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/12/21/abc2014w/</guid>
      <description>Android Bazaar and Conference 2014 Winterに参加してきました。
なかなか興味深いお話を聞けたので、気になった部分を抜粋
 携帯は９５％の人類が持ってる
 インターネットを利用するのは４割 スマホ利用者は３２％ スマホは１０年前の携帯と同じ水準まで来てる -１０年後は世界の携帯がスマホに置き換わる 今後１０年間で７０億人がインターネットに繋がる Androidは今のところ全世界で84.4%のシェア  各国のもの作り政策
 ドイツのINDUSTRIE 4.0 第四次産業革命 多数の企業を結んだバリューネットワーク 工場内の結合されたネットワーク　は出来てる
 アメリカ
 AMP立ち上げ
 アメリカで発明し、アメリカで製造する
 Made in Americaの復活
 中国
 2008年以降世界の製造業売り上げTop
 EU全体を合わせて、ようやく中国をちょっと上回る  第１２期５カ年計画
 ５年で１６８兆円使う IoTを重視する   Googleが買収したNest
 http://japan.cnet.com/news/commentary/35042541/ ネットに繋がるサーモスタット  Android Wear
 WearのNotificationはアプリの顔になる ノイジーな通知をするとアンインストールされる リストから選んで起動するのではなく、通知によってしかるべきタイミングで起動する わざわざ起動するのは減っていく   </description>
    </item>
    
    <item>
      <title>参加記録 Go Conference 2014 autumn</title>
      <link>http://ota42y.com/blog/2014/12/01/gocon-2014-autumn/</link>
      <pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/12/01/gocon-2014-autumn/</guid>
      <description>Go Conference 2014 autumnに参加しました。
togetterまとめ
大体スライドが公開されているので、正確な内容はそちらをどうぞ。
#まとめ - Go言語のシンプルさへのこだわりが凄い - 開発陣の徳の高さが凄い - 難しい部分は俺らに任せておけ！的な - 明日から使えるGo言語的な情報が盛りだくさん - エラーを_で無視して済みません…(´･_･`) - 椅子が痛い - 1時間半じゃなくて、1時間ごとぐらいに休憩を挟んでほしかったです… - 英語頑張ろう - 日本語スライドありがたや…
#Keynote1: Rob Pike (@rob_pike) (45min) スライドは未公開？
Go言語の設計者ロブ・パイクさんのGo言語の思想とかについての話です。
Go言語がいかに単純さ(≒簡潔さ)を重要視しているかについてとても示唆のある話をしていただけました。
他の言語が相互に機能を取り込み、ほぼ同じ機能を持つように進化していっているのに対し、
Goは1.0の時点で言語の機能を固定し、機能をとても少なく持つようにしたそうです。
書く楽しさはなくなるけど、代わりに保守のしやすさを選んだとのことです。
プレゼンの中で特にハッとさせられたのは、単純なコードと簡潔なコードとは異なるということです。
言語の機能を使って、数行程度でいろんな事に対応しようとすると、コードの量自体は少なくて済みますが、
必要とする前提知識が増え、かつその数行を完全に理解するのにとても時間がかかります。
おそらく、適当な言語のワンライナーを理解するのに必要な知識と時間を想像すれば大体わかると思います。
簡潔な記述でも理解するのが大変な複雑な事ができるため、
簡潔なコード≠単純なコードと言えるのかなと思いました。
また、Goではコード側ができる限り簡単になるように、
複雑な事を可能な限り言語側で隠蔽しているとも言われていました。
実際、GoのGCや並行処理、パッケージなどは設計や実装自体は凄く複雑にも関わらず、
使う側からはそれほど大変さを感じることなく使えます。
ここ（複雑な部分）は俺にまかせろーといった感じで、開発者の方々には頭が下がります…
#Keynote2: Goに入ってはGoに従え @fumitoshi_ukai (45min) 資料
Google社内でGo Readability Approverをされている@fumitoshi_ukaiさんの発表です。
Go言語らしく書くにはどうすればいいのか？といった思想的な部分と、
ダメな例と良い例を挙げてひたすら赤ペン先生をする発表でした。
これがGo言語のやり方か！となりっぱなしで、まさに明日から使えるGo言語といった感じなので、
是非ともスライドが公開されるといいなーと思います。
LT1 Gardener &amp;amp; Go 資料
@nuki_ponさんが某位置情報ゲームの色をした、GoCon Tシャツを作ってくださったそうです。
GoCon 2014 Autumn Tシャツ | FreeGufo メール便対</description>
    </item>
    
    <item>
      <title>参加記録 BPStudy ♯87</title>
      <link>http://ota42y.com/blog/2014/11/29/bpstudy-87/</link>
      <pubDate>Sat, 29 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/11/29/bpstudy-87/</guid>
      <description>BPStudy#87に参加しました。
togetterまとめ
じっくりと把握する iOS8 / iPhone6 最前線〜ユーザーにとって、開発者にとって何が変わったのか？ http://www.slideshare.net/yukio.andoh/bpstudy-87-ios8-iphone6
iOS8とiPhone6の新機能まとめと、それによって生じる問題紹介でした。
スライド46ページ目の親指の可動範囲の図を見せられると一目瞭然ですが、
画面サイズが大きくなったことによるタッチ領域の変化はとても激しく、
iPhone6や6+では従来のUIはかなり使いづらいものになってしまいます。
あと、リモートで任意の端末をレンタルできるRemote TestKitが凄い便利そうでした。
Remote TestKit
iPhone 6がリリースされて2ヶ月が過ぎました　〜iOSの分断化時代を乗り切ろう〜 http://www.slideshare.net/masashiono1/bpstudy-87
akisute/AutoLayoutTest
前半のスワイプUIのススメは、前の発表のiPhone6や6+向けのUIの回答として、
かなり良い回答ではないかなと思いました。
あと後半のSwiftのまとめが、Swiftの闇をひしひしと感じる内容で凄いです…(:3 」∠)
LT 一件目はiOS7と8で遭遇したブラウザバグの紹介でした。
資料
画像を範囲指定で切り抜くと何故か指定したサイズより大きくなるとか、
同時接続数が2個になったが、レスポンスの受信時間がかぶるとクラッシュするので同時接続してはいけないとか、
かなり辛い感じのバグが多かったです…
二件目ではペアプロ合コンに参加した人が、相手側の女性の手によって公開処刑される様子を見物していました…
恐ろしい…(((;ﾟДﾟ)))ｶﾞｸﾌﾞﾙｶﾞｸﾌﾞﾙ</description>
    </item>
    
    <item>
      <title>Dockerとは何か</title>
      <link>http://ota42y.com/blog/2014/11/26/docker/</link>
      <pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/11/26/docker/</guid>
      <description>Dockerについて調べたので概要と簡単な使い方のメモ
Dockerとは何か いわゆるコンテナ型仮想化ツールの1つです。
VMwareやKVMのような完全仮想化と違い、
ユーザや、ネットワーク、ファイルシステムなどを隔離した環境を作ってそこで動くらしいです。
あくまで隔離された環境のため、環境ごと作る完全仮想化に比べてオーバーヘッドが少なく、
手元の数年前のmac book airでもかなり快適に動いています。
あくまでゲストOSを隔離環境に置いただけのため 、
ファイルシステムは分離されておらず、ホストからは中身が見えるのも特徴らしいです。
(ゲストからはホストの中身は当然見えない)
また、DockerではDockerfileというファイルに設定を書くことで、
その設定を反映した状態のコンテナを作成することが出来ます。
そのため、OSの状態をDockerfileとして管理でき、いわゆるimmutable infrastructureと相性がいいみたいです。
Docker上のCent OSにJenkinsを立てる Dockerの起動 Dockerコマンドを実行するためには、Macだとboot2dockerを
boot2docker startで起動し、そのとき提示された環境変数を設定する必要があります。
また、
boot2docker ip
を実行し、コンテナに対してアクセスできるようにする必要があります。
なお、この時出たURLは後で使います。
Cent OSの構築 Dockerfileの準備 以下のファイルをDockerfileという名前で適当なディレクトリに保存します。
FROM centos:centos6 RUN curl -o /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo RUN rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key RUN yum -y install java-1.7.0-openjdk jenkins  見ての通り、Jenkins公式の入れ方のコマンドを実行しているだけです。
コンテナの作成 次に、Dockerfileを保存したディレクトリで
docker build -t jenkins . を実行し、カレントディレクトリのDockerfileを使って、jenkinsというタグをつけてコンテナを作成させます。
コンテナの起動 docker run -p 8080:8080 -i -t jenkins bash
を実行してホストの8080とコンテナの8080を結びつけ、先ほど作ったjenkinsコンテナにbashで入り、</description>
    </item>
    
    <item>
      <title>スクフェス用パッケージの更新</title>
      <link>http://ota42y.com/blog/2014/11/12/scfes-update/</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/11/12/scfes-update/</guid>
      <description>前に作ったスクフェス用パッケージを更新しました。
https://github.com/ota42y/hubot-scfes
今回は、いつぐらいにレベルアップするかを計算するコマンドを用意しました。
真夜中にレベルアップが起きたりすると面倒なので、これを見て事前に石を使うなり、
別の難易度をやって遅らせるなりして、レベルアップのタイミング調整をすることが簡単になります。
# 次のレベルアップまでexを何回プレイするか hubot scfes levelup count 830 ex =&amp;gt; 10 # 次のレベルアップはいつか hubot scfes levelup time 830 ex =&amp;gt; next levelup is Sun Aug 3 2014 2:52:52 GMT+0900 (JST)  なお、現在のスタミナ値は考慮していないため、実際は今たまってる分だけ早くなります。</description>
    </item>
    
    <item>
      <title>スクフェス用の機能が詰まったHubotパッケージを作った</title>
      <link>http://ota42y.com/blog/2014/10/28/hubot-scfes/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/10/28/hubot-scfes/</guid>
      <description>スクフェス用の色々便利な機能が入ったHubotパッケージを作りました。
https://github.com/ota42y/hubot-scfes
今のところ主な機能は2つです。
スタミナがMaxになる時間になったら通知する hubot scfes remind stamina 10 50
で、スタミナの現在値が10、最大値が50の場合に、Maxになる時刻に通知してくれます。
それ以外の値の場合は調節してください。
スタミナがnの倍数になったときに通知する hubot scfes remind stamina 10 50 25
で、スタミナの現在値が10、最大値が50として、25の倍数の時に通知してくれます。
EXでちょうど使い切れるタイミングで通知するといった使い方を想定しています。
未実装機能 イベント終了までにどれくらいスタミナが回復するかとか、
レベルアップするのはいつぐらいになるかとか、
そういった頭の中で適当に計算してる奴を機能化していこうと思います。
ちなみにこいつは前に作ったstamina-calculatorを内部で使用しています。
node.jsで細かくパッケージに分けて開発ってどうやるんだろうなーと思って、実益と練習がてら作った感じです。</description>
    </item>
    
    <item>
      <title>進捗どうですか？を訪ねるhubotスクリプトを作った</title>
      <link>http://ota42y.com/blog/2014/10/05/shinchoku/</link>
      <pubDate>Sun, 05 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/10/05/shinchoku/</guid>
      <description> 作りました。
30分ごとに進捗どうですか？と聞いてきます。
何をやったかを計測するために定期的にログを残そうと思うのですが、
大体忘れるので、こうやって適度に通知することで思いだそう！という試みです。
使い方 進捗 startで30分ごとに進捗どうですか？と聞いてきます。
進捗 stopでストップします。
ホラー体験 setTimeoutが秒設定だと間違えて…(´･_･`)
コード  </description>
    </item>
    
    <item>
      <title>ソシャゲ用のスタミナ計算機を作った</title>
      <link>http://ota42y.com/blog/2014/10/02/social-game-stamina-calc/</link>
      <pubDate>Thu, 02 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/10/02/social-game-stamina-calc/</guid>
      <description> 作りました。
スタミナmaxまでどれくらいかなー？とか、次イベント曲(25消費)をやるのに区切りがいいのはいつかなー
みたいなのを計算するのが面倒だったので、その辺の計算を自動でやってくれます。
使い方 初期化 スタミナ1あたりいくつ回復するかはゲームによって違うので、コンストラクタで渡します。
なお、指定は秒で行います。
stamina_calculator = new StaminaCalculator 6*60
この例ですと、6分で1スタミナ回復するゲームになります。
指定した値までの回復時間(getNextMaxStaminaTime) 現在値と指定値を渡すと、指定した値までに何秒かかるかを返します。
Maxまでどれくらいかな？とか、50になるのは何分後か？みたいな計算に使います。
stamina_calculator.getNextMaxStaminaTime(10, 60)
指定した倍数の値まで回復する時間(getMultipleRecoveryTime) 現在値とMAX値、それと倍数を渡すことで、指定した倍数になる時間を返します。
今30で、一回25消費できるから、50か75か100になる時間を知りたい…みたいな時に使います。
next_multiple_time = calc.getMultipleRecoveryTime(10, 80, 25)
結果をDateオブジェクトにする メソッドを呼んだ時間から指定秒たった時点のDateオブジェクトを返します。
Dateオブジェクトのコンストラクタには、指定時間後のオブジェクトを作る方法が見当たらなかったので作りました。
stamina_calculator.convertToDate(second)
サンプルコード StaminaCalculator = require(&#39;stamina-calculator&#39;).StaminaCalculator; stamina_calculator = new StaminaCalculator 6*60 second = stamina_calculator.getNextMaxStaminaTime(10, 60) console.log second # 今から何秒後にスタミナが５０回復するか console.log stamina_calculator.convertToDate(second) # 現在時刻からスタミナが５０回復する時間がDateオブジェクトで帰ってくる  </description>
    </item>
    
    <item>
      <title>Travis CI Meetup Tokyoに行ってきた</title>
      <link>http://ota42y.com/blog/2014/09/18/travisci-meetup/</link>
      <pubDate>Thu, 18 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/18/travisci-meetup/</guid>
      <description>前半はTravis CIのデモ、真ん中てCEOのお話、最後にLTと三部構成でした。
こちらに動画があるそうです。
http://www.ustream.tv/recorded/52769967
デモは一通りのTravis CIの使い方をデモしていただきました。
何となくわかってるデフォルトの挙動などにちゃんと説明がはいり、
基礎知識を固めるには凄く良かったです。
また、いくつか知らない機能(sudo false)や、
.travis.ymlの書式をオンラインで確認できるTravis WebLint等が紹介されていました。
なお、デモに使ったリポジトリは以下にあるようです。
https://github.com/BanzaiMan/travis-intro-tokyo
CEOの話では、現在のjob数やVM数、サーバの数などを話していただきました。
それと後半では環境によって良くはまる10個が紹介されていました。
ファイルシステムのケースセンシティブや、GNUとBSDの違いだったり、aptから古いバージョンが消えたり、
タイムゾーンやOSの違いによる環境構築や言語自体のバグ等々…
ここ最近に当たった奴がいくつかあり頭が痛かったです…(´･_･`)
最後のLTではいろんな発表が行われました。
見つけた分だけまとめておきます。
Automated releasing iOS app with Travis CI https://speakerdeck.com/kishikawakatsumi/automated-releasing-ios-app-with-travis-ci
私はJenkinsを使っていますが、似たような構成でやってるので参考になりました。
ただ、ビルド時間が5倍ぐらい長いので、こちらのプロジェクトにそのまま導入は難しそうです…
xcarchiveに書き出すと、申請用ビルドでテストフライトに出せるというのは新たな発見でした。
(追記: 発表者様から指摘がありました)　@ota42y 僕の話し方が悪かったのですが、xcarchiveだから、というわけではなくて、AppStoreとAdHocのプロビジョニングは互換性があるので、xcarchiveからipaにするところでプロビジョニングをAdHocにしています。同じビルドで署名だけ変える方法です。
&amp;mdash; kishikawa katsumi (@k_katsumi) 2014, 9月 18 
Travis CI API LT https://speakerdeck.com/pinzolo/travis-ci-api-lt
Travis CIのAPIと、gemの利用例です。
パッと見た限り、必要最低限は揃ってそうなので、hubotから叩くみたいなことが出来そうです。
QUnit on Travis CI @shigemk2 https://shigemk2.github.io/travisci_jp/#/step-1
jsのライブラリを作った際の利用例でした。
実際に作る際に参考に出来そうでした。
When was the build passing? http://sanemat.github.io/talks/20140917-travis-ci-meetup-tachikoma-io/
依存してるライブラリが更新すると、いつの間にかテストが落ちるようになってるけど、
テストが実行されないとわからないので、活発でないプロジェクトだと大変だよね…って話です。
これに対して、定期的にPRを送るTachikoma.io - Interval Pull Request Appというものを作ったそうです。</description>
    </item>
    
    <item>
      <title>スタックに確保した変数の有効範囲に気をつける</title>
      <link>http://ota42y.com/blog/2014/09/16/stack-heap/</link>
      <pubDate>Tue, 16 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/16/stack-heap/</guid>
      <description>C++にはスタックとヒープという、使い方の違うメモリ領域が存在します。
rubyとかjavaではこのような違いは基本的に意識する必要が無いため、間違った使い方をしてしまう場合があります。
例えば、普通の変数はスタックに積まれるため、スコープを抜けるとたとえ使っていても破棄されます。
以下に、関数の中で文字バッファをスタックに確保し、その参照を戻す関数の間違った例を上げます。
#include &amp;lt;string&amp;gt; #include &amp;lt;stdio.h&amp;gt; char *getTextFilename(const char* basename){ char str[1024] = {0}; strncpy(str, basename, strlen(basename)+1); strncat(str, &amp;quot;.txt&amp;quot;, 5); return str; } int main(void){ char *test_filename = getTextFilename(&amp;quot;test&amp;quot;); printf(&amp;quot;%s\n&amp;quot;, test_filename); char *example_filename = getTextFilename(&amp;quot;example&amp;quot;); printf(&amp;quot;%s\n&amp;quot;, example_filename); printf(&amp;quot;%s\n&amp;quot;, test_filename); return 0; }  環境によりますが、おそらく二回目のtest_filenameの出力がおかしくなると思います。
私の場合は以下のように、test_filenameにexample_filenameの内容が書き込まれていました。
test.txt example.txt example.txt  getTextFilename内のstrはスタックに確保されるので、関数終了時に解放されます。
そのため、戻り値の指し示す文字列は解放済みメモリとなり、勝手に変更される可能性があります。
上の例ではたまたま同じアドレスが再利用されたため、同じ文字列が設定されました。
ですが、間に様々な処理を実行した場合は、謎の値が書き込まれるなどがあり得るため注意が必要です。
対策 このような場合、いくつかの対策があります。
引数で渡す 1つ目が、strncpyやstrncatのように、メモリ利用域を引数として受け取る方法です。
これにより、自分のスコープから外れても値を保持することができます。
先ほどの例ですと、main側でcharの配列を確保して関数の引数でそれを受け取るといった形です。
確保したスコープを抜けるとやはり解放されますが、確実に解放されるためとても楽です。
ヒープに確保する 2つ目はmallocやnewでヒープ領域に確保する方法です。
以下はnewで配列を確保するように書き換えました。
#include &amp;lt;string&amp;gt; #include &amp;lt;stdio.h&amp;gt; char *getTextFilename(const char* basename){ char *str = new char[1024]; strncpy(str, basename, strlen(basename)+1); strncat(str, &amp;quot;.</description>
    </item>
    
    <item>
      <title>第47回情報科学若手の会2014に参加してきた</title>
      <link>http://ota42y.com/blog/2014/09/15/wakate2014/</link>
      <pubDate>Mon, 15 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/15/wakate2014/</guid>
      <description>2014年9月13日(土)〜15日(月)に静岡県伊東市の山喜旅館で開催された、
第47回情報科学若手の会2014に参加してきました。
二年ぶり三回目の参加です。
今回はLTもやりました。
当日の様子はこちらのまとめをどうぞ
第47回情報科学若手の会2014 ツイートまとめ #wakate2014
旅館について 山喜旅館さんのネットワークが超強化されていました。
2年前とは雲泥の差でとても快適で、導入した旅館と幹事さんには頭が下がります…
50人数位が普通に使っても回線部分はびくともしなかったため、 開発合宿には最適ではないでしょうか(宣伝)
発表について 今年は大学の講義をこれにしてくれれば…みたいな、凄くわかりやすい発表が多かったです。
私が把握した範囲で、公開されている資料をまとめました。
招待講演: サイバーセキュリティの世界に飛び込こもう！ 招待講演の資料は公開されていないようですが、紹介されていたnicterとDAEDALUSはとても凄いシステムでした。
従来なら、テキストベースのログとしてしか表現されていなかった悪意のある攻撃を、
わかりやすくかつリアルタイムに(さらにかっこよく)可視化しており、まさに機能美を揃えたシステムでした。
映像を見つけたので是非見ておくことをオススメします。
ネットワーク攻撃可視化・分析技術 - nicter #DigInfo
サイバー攻撃をリアルタイムに可視化、警告を発する「DAEDALUS」 #DigInfo
若手特別講演: 本当は楽しいインターネット http://www.slideshare.net/yuyarin/ss-39061287
インターネットへの愛がある上に、基本的な事柄を凄くわかりやすく説明していただいてます。
特にAS周りの話は名前を聞いたことがある…ぐらいの知識でしたので、
この資料で凄く良く理解することが出来ました。
ないんたんの天気予報と画像処理アルゴリズム（2014年9月13日 情報科学若手の会） https://docs.google.com/presentation/d/1KSIVmHvBR57uzJUkDEIMgi7JpAW51KequMCuws5COdY/edit#slide=id.p
画像処理のオプティカルフローを使って、天気の画像からその先の状態を計算して予報しているらしいです。
割と簡単で、計算量もさくらVPSで1秒ぐらいなのに、
精度の高い結果がでていて凄いなーと思いました。はぴぴーん
シュワルツ超関数としての信号処理理論 http://pel.es.hokudai.ac.jp/~akita/SignalAsDistribution.pdf
実際の発表資料とは違いますが参考資料として…
フーリエ変換系のは種類が色々あって、どこに何を使うのかよくわからなかったのですが、
とてもわかりやすく整理して話していただけました。
また、階段関数の微分はぱっと見意味不明だったのが、
話を聞くとちゃんと理解できるようになっていて、おお！って思いました。
私の発表 http://ota42y.com/blog/2014/09/14/wakate2014-presentation/
その他 交流会 交流会では謎解きゲームが行われました。
旅館の一階を全体的に使って謎探しから始まり、旅館やITに関係していそうな謎が用意されていました。
謎をを説いたチームには景品もあり、かなり白熱していました。
難易度やチーム編成も工夫されており、とても良かったです。
ナイトセッション 例年のごとく、中々濃い話や他では言えない話が繰り広げられていました。
例によって４時や５時ぐらいまで行われていたみたいですが、
さすがに体がついていかなく、２時３時でダウンしていました…
参加者の中に機械式計算機を持ってきてくださった方がいました。
所々の機械式ならではの工夫が見られ、初めて見た私にとっては凄く新鮮でした。
特にオーバーフロー、アンダーフローした時にベルがなるのは素晴らしかったです。

まとめ 帰りにkuro_m88さんと、「HCI系の人いないですよね−」と話していたんですが、
いないなら多分HCI系の話をするのは凄い有用だろうし、
来年はHCI系の話で一般かショート発表に申し込みたいと思います。
その後 帰りは三島の桜屋でうな重を食べました。</description>
    </item>
    
    <item>
      <title>情報科学若手の会2014で発表してきた</title>
      <link>http://ota42y.com/blog/2014/09/14/wakate2014-presentation/</link>
      <pubDate>Sun, 14 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/14/wakate2014-presentation/</guid>
      <description> LT発表してきました。
最近CIとか継続的デリバリーとか流行ってるけど、
ネット上にあふれている事例は、テスト(ビルド)が頑張れば5分程度で出来たり、
ユーザにすぐに提供できるWebサービスの話が多く、
それ以外の事例に適応した話が全然無いなーと思っていました。
特にスマホアプリでは、一つのjobに時間がかかったり、
ユーザに届けるのにもの凄く時間がかかるため、
良くあるやり方をそのまま持って行っても、
全然上手くいかないんですよね。
ただし、やり方をそっくり持ってくるんじゃなくって、
その手法をやると何がうれしいの？を考えていくと、
自ずとその環境に沿ったいい方法、というのが見つかる気がします。
より実践的なTipsになるので削った補足事項等
 コンパイルだけに出来ないのか  ビルドのほとんどがコンパイル時間なのでそれほど効果がありません…(´･_･`)  キャッシュは使っていないのか  キャッシュが悪さをする可能性が考えられるため意図的に切っています。
手元で開発する場合は活用しています。  ビルド自体の速度は速くしないのか  分散コンパイル等で早くできますが、Xcodeは対応していないのでAndroidのみになり、
そんなに効果がありません。  スライドで並列ビルドすればいいじゃん！と書いてますが、それも問題があります  アップロード先が並列で受け付けていないので、デプロイ時に失敗しまくります 排他制御しようとすると、Jenkinsの仕様とJob割り振りがよろしくないので
もの凄く辛いことになります。   </description>
    </item>
    
    <item>
      <title>パスワードの文字として避けた方がいい文字</title>
      <link>http://ota42y.com/blog/2014/09/08/password-word/</link>
      <pubDate>Mon, 08 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/08/password-word/</guid>
      <description>ニンテンドー3DSのプリペイドカード入力画面を見て、
見間違えやすい文字は使わないようにしてるんだーと気づいたので、
他にもそういうのが無いかまとめました。
もちろんaやtに代表されるように、フォントによって形は全然違うため、
全ての状況に対して当てはまるとは限りませんが、
目安程度としては使えると思います。
横一列が間違える可能性の高い文字集合です。
||||||| |::| |0|o|O|Q|D| |1|7|i|I|l| |2|z|Z| |5|s|S| |6|b| |8|B| |9|q|g| |a|d| |c|C| |k|K| |u|U|v|V| |w|W| |x|X| |z|Z|
まとめると、
数字だけを扱う場合は
2 3 4 5 6 8 9 0
小文字大文字を区別する場合は
3 4 e f h j m n p r y A E F G H J L M N P R Y
小文字大文字を区別しない場合は
3 4 c e f h j k m n p r t w x w x y z</description>
    </item>
    
    <item>
      <title>CEDEC2014 9月3日まとめ</title>
      <link>http://ota42y.com/blog/2014/09/06/cedec2014-09-03/</link>
      <pubDate>Sat, 06 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/09/06/cedec2014-09-03/</guid>
      <description>この日だけ参加したのでまとめ
ウェアラブルコンピューティングの動向とウェアラブルゲームへの展開  ウェアラブルの特徴
 コンピュータを服のように着る 常時ON 生活密着 ハンズフリー Occlusは基本的にウェアラブルではない  ウェアラブルは実は難しい
 装着して利用してみないと解らないことがたくさん ウェアラブルは一日中身につける（≠持ち歩く） モバイル機器とはまた別のノウハウが必要なのか。  汎用vs専用
 汎用 SmartWatch 高性能高機能 まだ実用性低い 専用 アクションカメラとか　 デジカメ、音楽プレーヤー等と同じく、少しづつ汎用の性能が上がっていく  ウェアラブルゲームではリアルの遊びが重要
 ちょっとした時間に暇つぶし ジョギングなど、別のことをしながら ファッション コンピュータはバーチャル空間に伸びたので、それとは違う道   「楽しさ」の設計と評価～我々はどこで失敗し，どこへ向かうのか  楽しさの評価
 完成するよりも前に、それが面白いものなのか、どうすれば面白くなるのか？ 経験則やコンテンツに左右されない、一般的な評価手法を探すのが目的らしい  心理学的手法
 アンケートとか かなりあやふや 過去にやったゲームとか 調整しました！と言われると、変わって無くても変わったと感じる  ３つ以上のパラメータを同時に調整するのは困難
 職人はベターは出せるがベストとは限らない パラメータか困難なものはよりわからない 調整可能な項目をクリアして、調整困難な協会に時間をかけるのがベター 調整可能  ロード時間のストレス ボタン反応の応答時間等  調整困難 ユーザに書ける適切なストレスとか  人間らしいAIの自動獲得
 見ていて機械的な不自然さを感じない 相手に合わせて強さを調整できるAI  人間の生物学的制約、人為的ミス・エラーの導入 揺らぎ、遅れ、使える、技術・知識の不足、錯誤・失念   人間らしさの評価</description>
    </item>
    
    <item>
      <title>受け取ったPOSTデータをチャットに送信するHubotスクリプトを作った</title>
      <link>http://ota42y.com/blog/2014/08/29/hubot-post-server/</link>
      <pubDate>Fri, 29 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/08/29/hubot-post-server/</guid>
      <description>実はHubotはWebサーバを立ち上げており、チャットからの入力以外にも、
Webサーバへのアクセスに対して反応することができます。
例: scripts/httpd.coffee
今回はその機能を利用し、
/hubot/send_messageにPOSTされたデータをチャットに流すスクリプトを作りました。
Hubot以外のアプリからこのURLを叩くことで、hubotの接続しているチャットに対して簡単にデータを送信できます。
 </description>
    </item>
    
    <item>
      <title>Evernoteのノートリンクが仕様変更で使い物にならないので何とかしようとした</title>
      <link>http://ota42y.com/blog/2014/08/10/evernote-link/</link>
      <pubDate>Sun, 10 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/08/10/evernote-link/</guid>
      <description>まとめ  Evernoteのノートリンクの仕様が変わって使い物にならなくなった 前の仕様でも動くので変換スクリプトを書いた ただし、Macではスクリプトの実行方法で問題あり  Evernoteのノートリンク仕様の変更 Evernoteでは図のように、「ノートリンクをコピー」で特定のノートに一対一対応するURIを取れます。
この機能でコピーされるのは、これまでは evernote:///という独自スキームが使われていました。
そのため、開こうとするとEvernoteアプリが立ち上がり、対応するノートを開いてくれていました。
AndroidやiPhoneでもEvernoteアプリをインストールしてあれば、
同じようにアプリでノートを開いてくれるため、とても便利でした。
しかし、最近の変更により、https://www.evernote.com/ へのリンクに変わってしまい、
ブラウザが起動してノートがEvernoteのサイト上で表示され、
そこからさらにEvernoteのアプリが開くという挙動になりました。
これにより、モバイル端末などではEvernoteへの通信時間が余計にかかるようになったうえに、
オフライン状態ではノートを開くことができなくなってしまいました。
正直使い物にならないレベルになってしまったのですが、
幸いなことにevernote:///スキームは未だ有効です。
また、必要な情報はどちらにも含まれているため、URIの変換スクリプトを書くことで対応可能です。
リンク置換スクリプトの作成 ノートリンクの仕様 以下は予想であり、正確なものではありません
Evernoteのhttpsリンクは以下のようになっています。
https://www.evernote.com/shard/s2/nl/ユーザ固有の文字列/ノート固有の文字列/
対して、evernote:///スキームは以下のようになっています。
evernote:///view/ユーザ固有の文字列/s2/ノート固有の文字列/ノート固有の文字列/
(ノート固有の文字列は二回とも同じ値になります)　どちらもユーザ固有の文字列とノート固有の文字列は含まれているため、相互に変換可能です。
Windowsならクリップボードの置換ソフトはたくさんあるのですが、
Macでは残念ながらまともな物はありませんでした。
一応、ClipMenuは正規表現で置換ができますが、
それを実行するまでにかなりキーストロークが必要なため、見送りました。
理想は自動置換、最低でもスクリプトを簡単に実行できるのが最低条件です。
リンク置換スクリプト 結局、クリップボードのURLをevernote:///に変換するスクリプトを作りました。
事前にclipboard gemをインストールしておく必要があります。
#!/bin/bash pushd $(dirname $0) bundle exec ruby -e &amp;quot; require &#39;clipboard&#39; url = Clipboard.paste r = Regexp.new(\&amp;quot;https://www.evernote.com/shard/s2/nl/([0-9]*)/(.*)/\&amp;quot;) result = r.match url if result new_url = \&amp;quot;evernote:///view/#{result[1]}/s2/#{result[2]}/#{result[2]}/\&amp;quot; p new_url Clipboard.copy new_url end &amp;quot; popd  これをevernote.</description>
    </item>
    
    <item>
      <title>2進数の引き算で補数を使う</title>
      <link>http://ota42y.com/blog/2014/07/18/2jin-shu-falseyin-kisuan-debu-shu-woshi-u/</link>
      <pubDate>Fri, 18 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/07/18/2jin-shu-falseyin-kisuan-debu-shu-woshi-u/</guid>
      <description>2進数の引き算で補数表現を使うと足し算にできることの説明が見あたら無かったのでやってみる
ここでは2の補数表現の求め方がすでに解っている前提で進める、
(要するに1000-101=010+1=011は相互に変換可能ということ)
結果がプラスになる場合
x = 5 - 2 (10進数) x = 101 - 010 (2進数に変換) x + 1000 = 101 - 010 + 1000 (両辺に+1000) x + 1000 = 101 + (1000 - 010) x + 1000 = 101 + 110 (2の補数表現) x + 1000 = 1011 x = 1011 - 1000 x = 11 x = 3 (10進数に変換)  結果がマイナスになる場合
x = 2 - 5 (10進数) x = 010 - 101 (2進数に変換) x + 1000 = 010 - 101 + 1000 (両辺に+1000) x + 1000 = 010 + (1000 - 101) x + 1000 = 010 + 011 (2の補数表現) x + 1000 = 101 x = 101 - 1000 x = - (1000 - 101) x = - (11) (2の補数表現) x = - (3) (10進数に変換) x = - 3  </description>
    </item>
    
    <item>
      <title>GitHub Kaigiに行ってきた</title>
      <link>http://ota42y.com/blog/2014/06/03/github-kaigi/</link>
      <pubDate>Tue, 03 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/06/03/github-kaigi/</guid>
      <description>スライドまとめ  GitHub実践入門は活用するためのガイドブック
 はてなブログチームの開発フローとGitHub
 OSS と GitHub
 How GitHub Works (GitHub Kaigi, Tokyo, 2014)
 GitHubで雑誌・書籍を作る
 Atom, the Programmable Text Editor
 入門書には載ってない Git &amp;amp; GitHub Tips
  LTは用事があって聞けませんでした…(´･_･`)
感想 全体的な感想 githubのハックや事例はもちろんですが、
どちらかというとgithubを利用してのワークフローとか、
エンジニアを含む環境がどう変化したか的なお話が多かったです。
一番はじめの、GitHub実践入門や、Gitのティップスに関しては、
すぐに導入したいような内容ばかりでした。
特に前者は凄くいい本っぽかったので(載せられてる)、会場で注文しましたw
Atomの発表が凄かった 他にもいろいろ発表がありましたが、特に私にヒットしたのは、Atomのプレゼンでした。
AtomはChromiumベースで、エディタ部分をHTML5/CSSで作っているので、
Developer Toolsを使ってWebサイトのように、Atomのデザインを変えられます。
プレゼン中に変更している様子を見せてもらいましたが、
本当に何でもリアルタイムで変更できて凄く未来を感じました。
また、DOM要素を直接いじることで、APIが提供されていなくても、
画面上の全ての要素(Macのメニューバーに出てる部分ですら！）を
自由に変更することが可能で、javascriptをコンソールに書いて、
新しいメニューがついたのは本当に度肝を抜かれました。
スライドの資料には映像がないため、
後日映像がアップロードされるのを待つしか無いのが凄く残念ですが、
とにかく未来を感じるエディタでした。
もの凄くおもしろかったので、第二回開催はまだですかね。</description>
    </item>
    
    <item>
      <title>Webで何かを作る人誰もが読むべき本だった - ハイパフォーマンス ブラウザネットワーキング</title>
      <link>http://ota42y.com/blog/2014/05/13/browser-networking/</link>
      <pubDate>Tue, 13 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://ota42y.com/blog/2014/05/13/browser-networking/</guid>
      <description>丸一日かけて読んだので書評っぽいのを。
Webで何かしようとする人はどのレイヤの人も必読だと思います。
インフラはもちろんのこと、アプリを作っている人も知らないでは済まされません。

ハイパフォーマンス ブラウザネットワーキング ―ネットワークアプリケーションのためのパフォーマンス最適化
#概要
目次としてはこんな感じで、TCP/UDPから無線ネットワークの特性から最新のプロトコルまで、
今のインターネットに触れる場合に触りそうな部分を、だいたいカバーしてます。
特にTCPとHTTP、WebRTCについてはとてもしっかりと書かれていました。
また具体的な最適化や、目次に乗っていない関係する技術に関してはかなりばっさり切り落としており、
取り扱っている内容の割にはすんなり読むことができました。
1章　レイテンシ・帯域幅入門 2章　TCPの構成要素 3章　UDPの構成要素 4章　TLS II部　ワイヤレスネットワークのパフォーマンス 5章　ワイヤレスネットワーク入門 6章　WiFi 7章　モバイルネットワーク 8章　モバイルネットワークの最適化 III部　HTTP 9章　HTTPの歴史 10章　Webパフォーマンス入門 11章　HTTP 1.x 12章　HTTP 2.0 13章　アプリケーション配信最適化 IV部　ブラウザAPIとプロトコル 14章　ブラウザネットワーク入門 15章　XMLHttpRequest 16章　Server-Sent Events 17章　WebSocket 18章　WebRTC  本のレベルとしては、3ウェイ・ハンドシェイクの基礎から教えてくれたりと、
かなり詳細に説明してくれるため、TCPやHTTPの詳しい知識は必要ありません。
だだし、ネットワークとは何かとかサーバとは何かとかの説明はないので、
最低限のネットワークの知識は必須です。
#感想
この本で特にいいと思ったところは、定義通りの何もしていない状態から、
順序立てて一つ一つ効率良くしていく様子を示している所です。
これはキープアライブからHTTPパイプラインの説明のところが顕著ですが、
まずはじめに何も考えずに愚直にやって、どれだけ無駄が多いかを説明し、
次にキープアライブを有効にすることでこれだけ無駄が省ける、
さらにHTTPパイプラインでこんなに無駄が省ける。</description>
    </item>
    
  </channel>
</rss>